<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>ntlm.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">ntlm.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/* NTLM SASL plugin
 * Ken Murchison
 * $Id: ntlm.c,v 1.6 2006/01/24 20:37:26 snsimon Exp $
 *
 * References:
 *   <a href="http://www.innovation.ch/java/ntlm.html">http://www.innovation.ch/java/ntlm.html</a>
 *   <a href="http://www.opengroup.org/comsource/techref2/NCH1222X.HTM">http://www.opengroup.org/comsource/techref2/NCH1222X.HTM</a>
 *   <a href="http://www.ubiqx.org/cifs/rfc-draft/draft-leach-cifs-v1-spec-02.html">http://www.ubiqx.org/cifs/rfc-draft/draft-leach-cifs-v1-spec-02.html</a>
 */</span>
<span class="enscript-comment">/* 
 * Copyright (c) 1998-2003 Carnegie Mellon University.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The name &quot;Carnegie Mellon University&quot; must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For permission or any other legal
 *    details, please contact  
 *      Office of Technology Transfer
 *      Carnegie Mellon University
 *      5000 Forbes Avenue
 *      Pittsburgh, PA  15213-3890
 *      (412) 268-4387, fax: (412) 268-7395
 *      <a href="mailto:tech-transfer@andrew.cmu.edu">tech-transfer@andrew.cmu.edu</a>
 *
 * 4. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    &quot;This product includes software developed by Computing Services
 *     at Carnegie Mellon University (<a href="http://www.cmu.edu/computing/">http://www.cmu.edu/computing/</a>).&quot;
 *
 * CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO
 * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE
 * FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
 * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;config.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdio.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdlib.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;ctype.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;errno.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;limits.h&gt;</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">WIN32</span>
# <span class="enscript-reference">include</span> <span class="enscript-string">&lt;process.h&gt;</span>	    <span class="enscript-comment">/* for getpid */</span>
  <span class="enscript-type">typedef</span> <span class="enscript-type">int</span> pid_t;
#<span class="enscript-reference">else</span>
# <span class="enscript-reference">include</span> <span class="enscript-string">&lt;unistd.h&gt;</span>
# <span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/types.h&gt;</span>
# <span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socket.h&gt;</span>
# <span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/utsname.h&gt;</span>
# <span class="enscript-reference">include</span> <span class="enscript-string">&lt;netdb.h&gt;</span>

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">SYS_NMLN</span>
  <span class="enscript-type">struct</span> utsname dummy;
# <span class="enscript-reference">define</span> <span class="enscript-variable-name">SYS_NMLN</span> sizeof(dummy.sysname)
#<span class="enscript-reference">endif</span>

# <span class="enscript-reference">define</span> <span class="enscript-function-name">closesocket</span>(sock)   close(sock)
  <span class="enscript-type">typedef</span> <span class="enscript-type">int</span> SOCKET;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* WIN32 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;openssl/md4.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;openssl/md5.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;openssl/hmac.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;openssl/des.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;openssl/opensslv.h&gt;</span>
#<span class="enscript-reference">if</span> (<span class="enscript-variable-name">OPENSSL_VERSION_NUMBER</span> &gt;= 0x0090700f) &amp;&amp; \
     !defined(OPENSSL_ENABLE_OLD_DES_SUPPORT)
# <span class="enscript-reference">define</span> <span class="enscript-variable-name">des_cblock</span> DES_cblock
# <span class="enscript-reference">define</span> <span class="enscript-variable-name">des_key_schedule</span> DES_key_schedule
# <span class="enscript-reference">define</span> <span class="enscript-function-name">des_set_odd_parity</span>(k) \
	 DES_set_odd_parity((k))
# <span class="enscript-reference">define</span> <span class="enscript-function-name">des_set_key</span>(k,ks) \
	 DES_set_key((k),&amp;(ks))
# <span class="enscript-reference">define</span> <span class="enscript-function-name">des_key_sched</span>(k,ks) \
         DES_key_sched((k),&amp;(ks))
# <span class="enscript-reference">define</span> <span class="enscript-function-name">des_ecb_encrypt</span>(i,o,k,e) \
	 DES_ecb_encrypt((i),(o),&amp;(k),(e))
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* OpenSSL 0.9.7+ w/o old DES support */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sasl.h&gt;</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MD5_H</span>  <span class="enscript-comment">/* suppress internal MD5 */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;saslplug.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;plugin_common.h&quot;</span>

<span class="enscript-comment">/*****************************  Common Section  *****************************/</span>

<span class="enscript-comment">//static const char plugin_id[] = &quot;$Id: ntlm.c,v 1.6 2006/01/24 20:37:26 snsimon Exp $&quot;;
</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">WIN32</span>
<span class="enscript-type">static</span> ssize_t <span class="enscript-function-name">writev</span> (SOCKET fd, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> iovec *iov, size_t iovcnt);

ssize_t <span class="enscript-function-name">writev</span> (SOCKET fd, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> iovec *iov, size_t iovcnt)
{
    ssize_t nwritten;		<span class="enscript-comment">/* amount written */</span>
    ssize_t nbytes;
    size_t i;
  
    nbytes = 0;

    <span class="enscript-keyword">for</span> (i = 0; i &lt; iovcnt; i++) {
	<span class="enscript-keyword">if</span> ((nwritten = send (fd, iov[i].iov_base, iov[i].iov_len, 0)) == SOCKET_ERROR) {
<span class="enscript-comment">/* Unless socket is nonblocking, we should always write everything */</span>
	    <span class="enscript-keyword">return</span> (-1);
	}

	nbytes += nwritten;
	  
	<span class="enscript-keyword">if</span> (nwritten &lt; iov[i].iov_len) {
	    <span class="enscript-keyword">break</span>;
	}
    }
    <span class="enscript-keyword">return</span> (nbytes);
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* WIN32 */</span>

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">UINT16_MAX</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">UINT16_MAX</span> 65535U
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">UINT_MAX</span> == <span class="enscript-variable-name">UINT16_MAX</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> uint16;
#<span class="enscript-reference">elif</span> <span class="enscript-variable-name">USHRT_MAX</span> == <span class="enscript-variable-name">UINT16_MAX</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">short</span> uint16;
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">error</span> <span class="enscript-variable-name">dont</span> <span class="enscript-variable-name">know</span> <span class="enscript-variable-name">what</span> <span class="enscript-variable-name">to</span> <span class="enscript-variable-name">use</span> <span class="enscript-variable-name">for</span> <span class="enscript-variable-name">uint16</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">UINT32_MAX</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">UINT32_MAX</span> 4294967295U
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">UINT_MAX</span> == <span class="enscript-variable-name">UINT32_MAX</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> uint32;
#<span class="enscript-reference">elif</span> <span class="enscript-variable-name">ULONG_MAX</span> == <span class="enscript-variable-name">UINT32_MAX</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> uint32;
#<span class="enscript-reference">elif</span> <span class="enscript-variable-name">USHRT_MAX</span> == <span class="enscript-variable-name">UINT32_MAX</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">short</span> uint32;
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">error</span> <span class="enscript-variable-name">dont</span> <span class="enscript-variable-name">know</span> <span class="enscript-variable-name">what</span> <span class="enscript-variable-name">to</span> <span class="enscript-variable-name">use</span> <span class="enscript-variable-name">for</span> <span class="enscript-variable-name">uint32</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NTLM_SIGNATURE</span>		<span class="enscript-string">&quot;NTLMSSP&quot;</span>

<span class="enscript-type">enum</span> {
    NTLM_TYPE_REQUEST		= 1,
    NTLM_TYPE_CHALLENGE		= 2,
    NTLM_TYPE_RESPONSE		= 3
};

<span class="enscript-type">enum</span> {
    NTLM_USE_UNICODE		= 0x00001,
    NTLM_USE_ASCII		= 0x00002,
    NTLM_ASK_TARGET		= 0x00004,
    NTLM_AUTH_NTLM		= 0x00200,
    NTLM_ALWAYS_SIGN		= 0x08000,
    NTLM_TARGET_IS_DOMAIN	= 0x10000,
    NTLM_TARGET_IS_SERVER	= 0x20000,
    NTLM_FLAGS_MASK		= 0x0ffff
};

<span class="enscript-type">enum</span> {
    NTLM_NONCE_LENGTH		= 8,
    NTLM_HASH_LENGTH		= 21,
    NTLM_RESP_LENGTH		= 24,
    NTLM_SESSKEY_LENGTH		= 16,
};

<span class="enscript-type">enum</span> {
    NTLM_SIG_OFFSET		= 0,
    NTLM_TYPE_OFFSET		= 8,

    NTLM_TYPE1_FLAGS_OFFSET	= 12,
    NTLM_TYPE1_DOMAIN_OFFSET	= 16,
    NTLM_TYPE1_WORKSTN_OFFSET	= 24,
    NTLM_TYPE1_DATA_OFFSET	= 32,
    NTLM_TYPE1_MINSIZE		= 16,

    NTLM_TYPE2_TARGET_OFFSET	= 12,
    NTLM_TYPE2_FLAGS_OFFSET	= 20,
    NTLM_TYPE2_CHALLENGE_OFFSET	= 24,
    NTLM_TYPE2_CONTEXT_OFFSET	= 32,
    NTLM_TYPE2_TARGETINFO_OFFSET= 40,
    NTLM_TYPE2_DATA_OFFSET	= 48,
    NTLM_TYPE2_MINSIZE		= 32,

    NTLM_TYPE3_LMRESP_OFFSET	= 12,
    NTLM_TYPE3_NTRESP_OFFSET	= 20,
    NTLM_TYPE3_DOMAIN_OFFSET	= 28,
    NTLM_TYPE3_USER_OFFSET	= 36,
    NTLM_TYPE3_WORKSTN_OFFSET	= 44,
    NTLM_TYPE3_SESSIONKEY_OFFSET= 52,
    NTLM_TYPE3_FLAGS_OFFSET	= 60,
    NTLM_TYPE3_DATA_OFFSET	= 64,
    NTLM_TYPE3_MINSIZE		= 52,

    NTLM_BUFFER_LEN_OFFSET	= 0,
    NTLM_BUFFER_MAXLEN_OFFSET	= 2,
    NTLM_BUFFER_OFFSET_OFFSET	= 4,
    NTLM_BUFFER_SIZE		= 8
};

<span class="enscript-comment">/* return the length of a string (even if it is NULL) */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">xstrlen</span>(s) (s ? strlen(s) : 0)

<span class="enscript-comment">/* machine-independent routines to convert to/from Intel byte-order */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">htois</span>(is, hs) \
    (is)[0] = hs &amp; 0xff; \
    (is)[1] = hs &gt;&gt; 8

#<span class="enscript-reference">define</span> <span class="enscript-function-name">itohs</span>(is) \
    ((is)[0] | ((is)[1] &lt;&lt; 8))

#<span class="enscript-reference">define</span> <span class="enscript-function-name">htoil</span>(il, hl) \
    (il)[0] = hl &amp; 0xff; \
    (il)[1] = (hl &gt;&gt; 8) &amp; 0xff; \
    (il)[2] = (hl &gt;&gt; 16) &amp; 0xff; \
    (il)[3] = hl &gt;&gt; 24

#<span class="enscript-reference">define</span> <span class="enscript-function-name">itohl</span>(il) \
    ((il)[0] | ((il)[1] &lt;&lt; 8) | ((il)[2] &lt;&lt; 16) | ((il)[3] &lt;&lt; 24))

<span class="enscript-comment">/* convert string to all upper case */</span>
<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span> *<span class="enscript-function-name">ucase</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *str, size_t len)
{
    <span class="enscript-type">char</span> *cp = (<span class="enscript-type">char</span> *) str;

    <span class="enscript-keyword">if</span> (!len) len = xstrlen(str);
    
    <span class="enscript-keyword">while</span> (len &amp;&amp; cp &amp;&amp; *cp) {
	*cp = toupper((<span class="enscript-type">int</span>) *cp);
	cp++;
	len--;
    }

    <span class="enscript-keyword">return</span> (str);
}

<span class="enscript-comment">/* copy src to dst as unicode (in Intel byte-order) */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">to_unicode</span>(u_char *dst, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *src, <span class="enscript-type">int</span> len)
{
    <span class="enscript-keyword">for</span> (; len; len--) {
	*dst++ = *src++;
	*dst++ = 0;
    }
}

<span class="enscript-comment">/* copy unicode src (in Intel byte-order) to dst */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">from_unicode</span>(<span class="enscript-type">char</span> *dst, u_char *src, <span class="enscript-type">int</span> len)
{
    <span class="enscript-keyword">for</span> (; len; len--) {
	*dst++ = *src &amp; 0x7f;
	src += 2;
    }
}

<span class="enscript-comment">/* load a string into an NTLM buffer */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">load_buffer</span>(u_char *buf, <span class="enscript-type">const</span> u_char *str, uint16 len,
			<span class="enscript-type">int</span> unicode, u_char *base, uint32 *offset)
{
    <span class="enscript-keyword">if</span> (len) {
	<span class="enscript-keyword">if</span> (unicode) {
	    to_unicode(base + *offset, str, len);
	    len *= 2;
	}
	<span class="enscript-keyword">else</span> {
	    memcpy(base + *offset, str, len);
	}
    }

    htois(buf + NTLM_BUFFER_LEN_OFFSET, len);
    htois(buf + NTLM_BUFFER_MAXLEN_OFFSET, len);
    htoil(buf + NTLM_BUFFER_OFFSET_OFFSET, *offset);
    *offset += len;
}

<span class="enscript-comment">/* unload a string from an NTLM buffer */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">unload_buffer</span>(<span class="enscript-type">const</span> sasl_utils_t *utils, <span class="enscript-type">const</span> u_char *buf,
			 u_char **str, <span class="enscript-type">unsigned</span> *outlen,
			 <span class="enscript-type">int</span> unicode, <span class="enscript-type">const</span> u_char *base, <span class="enscript-type">unsigned</span> msglen)
{
    uint16 len = itohs(buf + NTLM_BUFFER_LEN_OFFSET);

    <span class="enscript-keyword">if</span> (len) {
	uint32 offset;

	*str = utils-&gt;malloc(len + 1); <span class="enscript-comment">/* add 1 for NUL */</span>
	<span class="enscript-keyword">if</span> (*str == NULL) {
	    MEMERROR(utils);
	    <span class="enscript-keyword">return</span> SASL_NOMEM;
	}

	offset = itohl(buf + NTLM_BUFFER_OFFSET_OFFSET);

	<span class="enscript-comment">/* sanity check */</span>
	<span class="enscript-keyword">if</span> (offset &gt; msglen || len &gt; (msglen - offset)) <span class="enscript-keyword">return</span> SASL_BADPROT;

	<span class="enscript-keyword">if</span> (unicode) {
	    len /= 2;
	    from_unicode((<span class="enscript-type">char</span> *) *str, (u_char *) base + offset, len);
	}
	<span class="enscript-keyword">else</span>
	    memcpy(*str, base + offset, len);

	(*str)[len] = <span class="enscript-string">'\0'</span>; <span class="enscript-comment">/* add NUL */</span>
    }
    <span class="enscript-keyword">else</span> {
	*str = NULL;
    }

    <span class="enscript-keyword">if</span> (outlen) *outlen = len;

    <span class="enscript-keyword">return</span> SASL_OK;
}

<span class="enscript-comment">/*
 * NTLM encryption/authentication routines per section 2.10 of
 * draft-leach-cifs-v1-spec-02
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">E</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *out, <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *K, <span class="enscript-type">unsigned</span> Klen,
	      <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *D, <span class="enscript-type">unsigned</span> Dlen)
	      
{
    <span class="enscript-type">unsigned</span> k, d;
    des_cblock K64;
    des_key_schedule ks;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *Dp;
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">KEY_SIZE</span>   7
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">BLOCK_SIZE</span> 8

    <span class="enscript-keyword">for</span> (k = 0; k &lt; Klen; k += KEY_SIZE, K += KEY_SIZE) {
	<span class="enscript-comment">/* convert 56-bit key to 64-bit */</span>
	K64[0] = K[0];
	K64[1] = ((K[0] &lt;&lt; 7) &amp; 0xFF) | (K[1] &gt;&gt; 1);
	K64[2] = ((K[1] &lt;&lt; 6) &amp; 0xFF) | (K[2] &gt;&gt; 2);
	K64[3] = ((K[2] &lt;&lt; 5) &amp; 0xFF) | (K[3] &gt;&gt; 3);
	K64[4] = ((K[3] &lt;&lt; 4) &amp; 0xFF) | (K[4] &gt;&gt; 4);
	K64[5] = ((K[4] &lt;&lt; 3) &amp; 0xFF) | (K[5] &gt;&gt; 5);
	K64[6] = ((K[5] &lt;&lt; 2) &amp; 0xFF) | (K[6] &gt;&gt; 6);
	K64[7] =  (K[6] &lt;&lt; 1) &amp; 0xFF;

 	des_set_odd_parity(&amp;K64); <span class="enscript-comment">/* XXX is this necessary? */</span>
 	des_set_key(&amp;K64, ks);

	<span class="enscript-keyword">for</span> (d = 0, Dp = D; d &lt; Dlen;
	     d += BLOCK_SIZE, Dp += BLOCK_SIZE, out += BLOCK_SIZE) {
 	    des_ecb_encrypt((<span class="enscript-type">void</span> *) Dp, (<span class="enscript-type">void</span> *) out, ks, DES_ENCRYPT);
	}
    }
}

<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *<span class="enscript-function-name">P16_lm</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *P16, sasl_secret_t *passwd,
			     <span class="enscript-type">const</span> sasl_utils_t *utils __attribute__((unused)),
			     <span class="enscript-type">char</span> **buf __attribute__((unused)),
			     <span class="enscript-type">unsigned</span> *buflen __attribute__((unused)),
			     <span class="enscript-type">int</span> *result)
{
    <span class="enscript-type">char</span> P14[14];
    <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> S8[] = { 0x4b, 0x47, 0x53, 0x21, 0x40, 0x23, 0x24, 0x25 };

    strncpy(P14, (<span class="enscript-type">char</span> *)passwd-&gt;data, <span class="enscript-keyword">sizeof</span>(P14));
    ucase(P14, <span class="enscript-keyword">sizeof</span>(P14));

    E(P16, P14, <span class="enscript-keyword">sizeof</span>(P14), S8, <span class="enscript-keyword">sizeof</span>(S8));
    *result = SASL_OK;
    <span class="enscript-keyword">return</span> P16;
}

<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *<span class="enscript-function-name">P16_nt</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *P16, sasl_secret_t *passwd,
			     <span class="enscript-type">const</span> sasl_utils_t *utils,
			     <span class="enscript-type">char</span> **buf, <span class="enscript-type">unsigned</span> *buflen, <span class="enscript-type">int</span> *result)
{
    <span class="enscript-keyword">if</span> (_plug_buf_alloc(utils, buf, buflen, 2 * passwd-&gt;len) != SASL_OK) {
	SETERROR(utils, <span class="enscript-string">&quot;cannot allocate P16_nt unicode buffer&quot;</span>);
	*result = SASL_NOMEM;
    }
    <span class="enscript-keyword">else</span> {
	to_unicode(*buf, passwd-&gt;data, passwd-&gt;len);
	MD4(*buf, 2 * passwd-&gt;len, P16);
	*result = SASL_OK;
    }
    <span class="enscript-keyword">return</span> P16;
}

<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *<span class="enscript-function-name">P21</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *P21, sasl_secret_t *passwd,
			  <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> * (*P16)(<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *,
						 sasl_secret_t *,
						 <span class="enscript-type">const</span> sasl_utils_t *,
						 <span class="enscript-type">char</span> **, <span class="enscript-type">unsigned</span> *, <span class="enscript-type">int</span> *),
			  <span class="enscript-type">const</span> sasl_utils_t *utils,
			  <span class="enscript-type">char</span> **buf, <span class="enscript-type">unsigned</span> *buflen, <span class="enscript-type">int</span> *result)
{
    memset(P16(P21, passwd, utils, buf, buflen, result) + 16, 0, 5);
    <span class="enscript-keyword">return</span> P21;
}

<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *<span class="enscript-function-name">P24</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *P24, <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *P21,
			  <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *C8)
		      
{
    E(P24, P21, NTLM_HASH_LENGTH, C8, NTLM_NONCE_LENGTH);
    <span class="enscript-keyword">return</span> P24;
}

<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *<span class="enscript-function-name">V2</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *V2, sasl_secret_t *passwd,
			 <span class="enscript-type">const</span> <span class="enscript-type">char</span> *authid, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *target,
			 <span class="enscript-type">const</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *challenge,
			 <span class="enscript-type">const</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *blob, <span class="enscript-type">unsigned</span> bloblen,
			 <span class="enscript-type">const</span> sasl_utils_t *utils,
			 <span class="enscript-type">char</span> **buf, <span class="enscript-type">unsigned</span> *buflen, <span class="enscript-type">int</span> *result)
{
    HMAC_CTX ctx;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> hash[EVP_MAX_MD_SIZE];
    <span class="enscript-type">char</span> *upper;
    <span class="enscript-type">int</span> len;

    <span class="enscript-comment">/* Allocate enough space for the unicode target */</span>
    len = (<span class="enscript-type">int</span>) (strlen(authid) + xstrlen(target));
    <span class="enscript-keyword">if</span> (_plug_buf_alloc(utils, buf, buflen, 2 * len + 1) != SASL_OK) {
	SETERROR(utils, <span class="enscript-string">&quot;cannot allocate NTLMv2 hash&quot;</span>);
	*result = SASL_NOMEM;
    }
    <span class="enscript-keyword">else</span> {
	<span class="enscript-comment">/* NTLMv2hash = HMAC-MD5(NTLMhash, unicode(ucase(authid + domain))) */</span>
	P16_nt(hash, passwd, utils, buf, buflen, result);

	<span class="enscript-comment">/* Use the tail end of the buffer for ucase() conversion */</span>
	upper = *buf + len;
	strcpy(upper, authid);
	<span class="enscript-keyword">if</span> (target) strcat(upper, target);
	ucase(upper, len);
	to_unicode(*buf, upper, len);

	HMAC(EVP_md5(), hash, MD4_DIGEST_LENGTH, *buf, 2 * len, hash, &amp;len);

	<span class="enscript-comment">/* V2 = HMAC-MD5(NTLMv2hash, challenge + blob) + blob */</span>
	HMAC_Init(&amp;ctx, hash, len, EVP_md5());
	HMAC_Update(&amp;ctx, challenge, NTLM_NONCE_LENGTH);
	HMAC_Update(&amp;ctx, blob, bloblen);
	HMAC_Final(&amp;ctx, V2, &amp;len);
	HMAC_cleanup(&amp;ctx);

	<span class="enscript-comment">/* the blob is concatenated outside of this function */</span>

	*result = SASL_OK;
    }

    <span class="enscript-keyword">return</span> V2;
}

<span class="enscript-comment">/*****************************  Server Section  *****************************/</span>

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> server_context {
    <span class="enscript-type">int</span> state;

    uint32 flags;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> nonce[NTLM_NONCE_LENGTH];

    <span class="enscript-comment">/* per-step mem management */</span>
    <span class="enscript-type">char</span> *out_buf;
    <span class="enscript-type">unsigned</span> out_buf_len;

    <span class="enscript-comment">/* socket to remote authentication host */</span>
    SOCKET sock;

} server_context_t;

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">N</span>(a)			(sizeof (a) / sizeof (a[0]))

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">SMB_HDR_PROTOCOL</span>	<span class="enscript-string">&quot;\xffSMB&quot;</span>

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> {
    <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> protocol[4];
    <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> command;
    uint32 status;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> flags;
    uint16 flags2;
    uint16 PidHigh;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> extra[10];
    uint16 tid;
    uint16 pid;
    uint16 uid;
    uint16 mid;
} SMB_Header;

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> {
    uint16 dialect_index;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> security_mode;
    uint16 max_mpx_count;
    uint16 max_number_vcs;
    uint32 max_buffer_size;
    uint32 max_raw_size;
    uint32 session_key;
    uint32 capabilities;
    uint32 system_time_low;
    uint32 system_time_high;
    uint16 server_time_zone;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> encryption_key_length;
} SMB_NegProt_Resp;

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> {
    <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> andx_command;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> andx_reserved;
    uint16 andx_offset;
    uint16 max_buffer_size;
    uint16 max_mpx_count;
    uint16 vc_number;
    uint32 session_key;
    uint16 case_insensitive_passwd_len;
    uint16 case_sensitive_passwd_len;
    uint32 reserved;
    uint32 capabilities;
} SMB_SessionSetup;

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> {
    <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> andx_command;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> andx_reserved;
    uint16 andx_offset;
    uint16 action;
} SMB_SessionSetup_Resp;

<span class="enscript-type">enum</span> {
    NBT_SESSION_REQUEST		= 0x81,
    NBT_POSITIVE_SESSION_RESP	= 0x82,
    NBT_NEGATIVE_SESSION_RESP	= 0x83,
    NBT_ERR_NO_LISTEN_CALLED	= 0x80,
    NBT_ERR_NO_LISTEN_CALLING	= 0x81,
    NBT_ERR_CALLED_NOT_PRESENT	= 0x82,
    NBT_ERR_INSUFFICIENT_RESRC	= 0x83,
    NBT_ERR_UNSPECIFIED		= 0x8F,

    SMB_HDR_SIZE		= 32,

    SMB_COM_NEGOTIATE_PROTOCOL	= 0x72,
    SMB_COM_SESSION_SETUP_ANDX	= 0x73,
    SMB_COM_NONE		= 0xFF,

    SMB_FLAGS_SERVER_TO_REDIR	= 0x80,

    SMB_FLAGS2_ERR_STATUS	= 0x4000,
    SMB_FLAGS2_UNICODE		= 0x8000,

    SMB_NEGPROT_RESP_SIZE	= 34,

    SMB_SECURITY_MODE_USER	= 0x1,
    SMB_SECURITY_MODE_ENCRYPT	= 0x2,
    SMB_SECURITY_MODE_SIGN	= 0x4,
    SMB_SECURITY_MODE_SIGN_REQ	= 0x8,

    SMB_CAP_UNICODE		= 0x0004,
    SMB_CAP_STATUS32		= 0x0040,
    SMB_CAP_EXTENDED_SECURITY	= 0x80000000,

    SMB_SESSION_SETUP_SIZE	= 26,
    SMB_SESSION_SETUP_RESP_SIZE	= 6,

    SMB_REQUEST_MODE_GUEST	= 0x1
};

<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span> *SMB_DIALECTS[] = {
#<span class="enscript-reference">if</span> 0
    <span class="enscript-string">&quot;\x02PC NETWORK PROGRAM 1.0&quot;</span>,
    <span class="enscript-string">&quot;\x02PCLAN1.0&quot;</span>,
    <span class="enscript-string">&quot;\x02MICROSOFT NETWORKS 1.03&quot;</span>,
    <span class="enscript-string">&quot;\x02MICROSOFT NETWORKS 3.0&quot;</span>,
    <span class="enscript-string">&quot;\x02LANMAN1.0&quot;</span>,
    <span class="enscript-string">&quot;\x02Windows for Workgroups 3.1a&quot;</span>,
    <span class="enscript-string">&quot;\x02LM1.2X002&quot;</span>,
    <span class="enscript-string">&quot;\x02DOS LM1.2X002&quot;</span>,
    <span class="enscript-string">&quot;\x02DOS LANLAM2.1&quot;</span>,
    <span class="enscript-string">&quot;\x02LANMAN2.1&quot;</span>,
#<span class="enscript-reference">endif</span>
    <span class="enscript-string">&quot;\x02NT LM 0.12&quot;</span>
};

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">load_smb_header</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> buf[], SMB_Header *hdr)
{
    <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *p = buf;

    memcpy(p, SMB_HDR_PROTOCOL, 4); p += 4;
    *p++ = hdr-&gt;command;
    htoil(p, hdr-&gt;status); p += 4;
    *p++ = hdr-&gt;flags;
    htois(p, hdr-&gt;flags2); p += 2;
    htois(p, hdr-&gt;PidHigh); p += 2;
    memcpy(p, hdr-&gt;extra, 10); p += 10;
    htois(p, hdr-&gt;tid); p += 2;
    htois(p, hdr-&gt;pid); p += 2;
    htois(p, hdr-&gt;uid); p += 2;
    htois(p, hdr-&gt;mid);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">unload_smb_header</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> buf[], SMB_Header *hdr)
{
    <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *p = buf;

    memcpy(hdr-&gt;protocol, p, 4); p += 4;
    hdr-&gt;command = *p++;
    hdr-&gt;status = itohl(p); p += 4;
    hdr-&gt;flags = *p++;
    hdr-&gt;flags2 = itohs(p); p += 2;
    hdr-&gt;PidHigh = itohs(p); p += 2;
    memcpy(hdr-&gt;extra, p, 10); p += 10;
    hdr-&gt;tid = itohs(p); p += 2;
    hdr-&gt;pid = itohs(p); p += 2;
    hdr-&gt;uid = itohs(p); p += 2;
    hdr-&gt;mid = itohs(p);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">unload_negprot_resp</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> buf[], SMB_NegProt_Resp *resp)
{
    <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *p = buf;

    resp-&gt;dialect_index = itohs(p); p += 2;
    resp-&gt;security_mode = *p++;
    resp-&gt;max_mpx_count = itohs(p); p += 2;
    resp-&gt;max_number_vcs = itohs(p); p += 2;
    resp-&gt;max_buffer_size = itohl(p); p += 4;
    resp-&gt;max_raw_size = itohl(p); p += 4;
    resp-&gt;session_key = itohl(p); p += 4;
    resp-&gt;capabilities = itohl(p); p += 4;
    resp-&gt;system_time_low = itohl(p); p += 4;
    resp-&gt;system_time_high = itohl(p); p += 4;
    resp-&gt;server_time_zone = itohs(p); p += 2;
    resp-&gt;encryption_key_length = *p;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">load_session_setup</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> buf[], SMB_SessionSetup *setup)
{
    <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *p = buf;

    *p++ = setup-&gt;andx_command;
    *p++ = setup-&gt;andx_reserved;
    htois(p, setup-&gt;andx_offset); p += 2;
    htois(p, setup-&gt;max_buffer_size); p += 2;
    htois(p, setup-&gt;max_mpx_count); p += 2;
    htois(p, setup-&gt;vc_number); p += 2;
    htoil(p, setup-&gt;session_key); p += 4;
    htois(p, setup-&gt;case_insensitive_passwd_len); p += 2;
    htois(p, setup-&gt;case_sensitive_passwd_len); p += 2;
    htoil(p, setup-&gt;reserved); p += 4;
    htoil(p, setup-&gt;capabilities); p += 4;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">unload_session_setup_resp</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> buf[],
				      SMB_SessionSetup_Resp *resp)
{
    <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *p = buf;

    resp-&gt;andx_command = *p++;
    resp-&gt;andx_reserved = *p++;
    resp-&gt;andx_offset = itohs(p); p += 2;
    resp-&gt;action = itohs(p);
}

<span class="enscript-comment">/*
 * Keep calling the writev() system call with 'fd', 'iov', and 'iovcnt'
 * until all the data is written out or an error occurs.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">retry_writev</span>(SOCKET fd, <span class="enscript-type">struct</span> iovec *iov, <span class="enscript-type">int</span> iovcnt)
{
    <span class="enscript-type">int</span> n;
    <span class="enscript-type">int</span> i;
    <span class="enscript-type">int</span> written = 0;
    <span class="enscript-type">static</span> <span class="enscript-type">int</span> iov_max =
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MAXIOV</span>
	MAXIOV
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">IOV_MAX</span>
	IOV_MAX
#<span class="enscript-reference">else</span>
	8192
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">endif</span>
	;
    
    <span class="enscript-keyword">for</span> (;;) {
	<span class="enscript-keyword">while</span> (iovcnt &amp;&amp; iov[0].iov_len == 0) {
	    iov++;
	    iovcnt--;
	}

	<span class="enscript-keyword">if</span> (!iovcnt) <span class="enscript-keyword">return</span> written;

	n = writev(fd, iov, iovcnt &gt; iov_max ? iov_max : iovcnt);
	<span class="enscript-keyword">if</span> (n == -1) {
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">WIN32</span>
	    <span class="enscript-keyword">if</span> (errno == EINVAL &amp;&amp; iov_max &gt; 10) {
		iov_max /= 2;
		<span class="enscript-keyword">continue</span>;
	    }
	    <span class="enscript-keyword">if</span> (errno == EINTR) <span class="enscript-keyword">continue</span>;
#<span class="enscript-reference">endif</span>
	    <span class="enscript-keyword">return</span> -1;
	}

	written += n;

	<span class="enscript-keyword">for</span> (i = 0; i &lt; iovcnt; i++) {
	    <span class="enscript-keyword">if</span> ((<span class="enscript-type">int</span>) iov[i].iov_len &gt; n) {
		iov[i].iov_base = (<span class="enscript-type">char</span> *) iov[i].iov_base + n;
		iov[i].iov_len -= n;
		<span class="enscript-keyword">break</span>;
	    }
	    n -= iov[i].iov_len;
	    iov[i].iov_len = 0;
	}

	<span class="enscript-keyword">if</span> (i == iovcnt) <span class="enscript-keyword">return</span> written;
    }
}

<span class="enscript-comment">/*
 * Keep calling the read() system call with 'fd', 'buf', and 'nbyte'
 * until all the data is read in or an error occurs.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">retry_read</span>(SOCKET fd, <span class="enscript-type">char</span> *buf0, <span class="enscript-type">unsigned</span> nbyte)
{
    <span class="enscript-type">int</span> n;
    <span class="enscript-type">int</span> nread = 0;
    <span class="enscript-type">char</span> *buf = buf0;

    <span class="enscript-keyword">if</span> (nbyte == 0) <span class="enscript-keyword">return</span> 0;

    <span class="enscript-keyword">for</span> (;;) {
<span class="enscript-comment">/* Can't use read() on sockets on Windows, but recv works on all platforms */</span>
	n = recv (fd, buf, nbyte, 0);
	<span class="enscript-keyword">if</span> (n == -1 || n == 0) {
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">WIN32</span>
	    <span class="enscript-keyword">if</span> (errno == EINTR || errno == EAGAIN) <span class="enscript-keyword">continue</span>;
#<span class="enscript-reference">endif</span>
	    <span class="enscript-keyword">return</span> -1;
	}

	nread += n;

	<span class="enscript-keyword">if</span> (n &gt;= (<span class="enscript-type">int</span>) nbyte) <span class="enscript-keyword">return</span> nread;

	buf += n;
	nbyte -= n;
    }
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">make_netbios_name</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *in, <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> out[])
{
    size_t i, j = 0, n;

    <span class="enscript-comment">/* create a NetBIOS name from the DNS name
     *
     * - use up to the first 16 chars of the first part of the hostname
     * - convert to all uppercase
     * - use the tail end of the output buffer as temp space
     */</span>
    n = strcspn(in, <span class="enscript-string">&quot;.&quot;</span>);
    <span class="enscript-keyword">if</span> (n &gt; 16) n = 16;
    strncpy((<span class="enscript-type">char</span> *)out+18, in, n);
    in = out+18;
    ucase(in, n);

    out[j++] = 0x20;
    <span class="enscript-keyword">for</span> (i = 0; i &lt; n; i++) {
	out[j++] = ((in[i] &gt;&gt; 4) &amp; 0xf) + 0x41;
	out[j++] = (in[i] &amp; 0xf) + 0x41;
    }
    <span class="enscript-keyword">for</span> (; i &lt; 16; i++) {
	out[j++] = ((0x20 &gt;&gt; 4) &amp; 0xf) + 0x41;
	out[j++] = (0x20 &amp; 0xf) + 0x41;
    }
    out[j] = 0;
}

<span class="enscript-type">static</span> SOCKET <span class="enscript-function-name">smb_connect_server</span>(<span class="enscript-type">const</span> sasl_utils_t *utils, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *client,
			      <span class="enscript-type">const</span> <span class="enscript-type">char</span> *server)
{
    <span class="enscript-type">struct</span> addrinfo hints;
    <span class="enscript-type">struct</span> addrinfo *ai = NULL, *r;
    SOCKET s = (SOCKET) -1;
    <span class="enscript-type">int</span> err;
    <span class="enscript-type">char</span> * error_str;
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">WIN32</span>
    DWORD saved_errno;
#<span class="enscript-reference">else</span>
    <span class="enscript-type">int</span> saved_errno;
#<span class="enscript-reference">endif</span>
    <span class="enscript-type">int</span> niflags;
    <span class="enscript-type">char</span> *port = <span class="enscript-string">&quot;139&quot;</span>;
    <span class="enscript-type">char</span> hbuf[NI_MAXHOST], pbuf[NI_MAXSERV];

    <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> called[34];
    <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> calling[34];
    <span class="enscript-type">struct</span> iovec iov[3];
    uint32 pkt;
    <span class="enscript-type">int</span> rc;

    memset(&amp;hints, 0, <span class="enscript-keyword">sizeof</span>(hints));
    hints.ai_family = PF_UNSPEC;
    hints.ai_socktype = SOCK_STREAM;
    hints.ai_flags = AI_CANONNAME;
    <span class="enscript-keyword">if</span> ((err = getaddrinfo(server, port, &amp;hints, &amp;ai)) != 0) {
	utils-&gt;log(NULL, SASL_LOG_ERR,
		   <span class="enscript-string">&quot;NTLM: getaddrinfo %s/%s: %s&quot;</span>,
		   server, port, gai_strerror(err));
	<span class="enscript-keyword">return</span> -1;
    }

    <span class="enscript-comment">/* Make sure we have AF_INET or AF_INET6 addresses. */</span>
    <span class="enscript-keyword">if</span> (ai-&gt;ai_family != AF_INET &amp;&amp; ai-&gt;ai_family != AF_INET6) {
	utils-&gt;log(NULL, SASL_LOG_ERR, <span class="enscript-string">&quot;NTLM: no IP address info for %s&quot;</span>,
		   ai-&gt;ai_canonname ? ai-&gt;ai_canonname : server);
	freeaddrinfo(ai);
	<span class="enscript-keyword">return</span> -1;
    }

    <span class="enscript-comment">/* establish connection to authentication server */</span>
    <span class="enscript-keyword">for</span> (r = ai; r; r = r-&gt;ai_next) {
	s = socket(r-&gt;ai_family, r-&gt;ai_socktype, r-&gt;ai_protocol);
	<span class="enscript-keyword">if</span> (s &lt; 0)
	    <span class="enscript-keyword">continue</span>;
	<span class="enscript-keyword">if</span> (connect(s, r-&gt;ai_addr, r-&gt;ai_addrlen) &gt;= 0)
	    <span class="enscript-keyword">break</span>;
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">WIN32</span>
	saved_errno = WSAGetLastError();
#<span class="enscript-reference">else</span>
	saved_errno = errno;
#<span class="enscript-reference">endif</span>
	closesocket (s);
	s = -1;
	niflags = (NI_NUMERICHOST | NI_NUMERICSERV);
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">NI_WITHSCOPEID</span>
	<span class="enscript-keyword">if</span> (r-&gt;ai_family == AF_INET6)
	    niflags |= NI_WITHSCOPEID;
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">if</span> (getnameinfo(r-&gt;ai_addr, r-&gt;ai_addrlen, hbuf, <span class="enscript-keyword">sizeof</span>(hbuf),
			pbuf, <span class="enscript-keyword">sizeof</span>(pbuf), niflags) != 0) {
	    strcpy(hbuf, <span class="enscript-string">&quot;unknown&quot;</span>);
	    strcpy(pbuf, <span class="enscript-string">&quot;unknown&quot;</span>);
	}

        <span class="enscript-comment">/* Can't use errno (and %m), as it doesn't contain
         * the socket error on Windows */</span>
	error_str = _plug_get_error_message (utils, saved_errno);
	utils-&gt;log(NULL, SASL_LOG_WARN, <span class="enscript-string">&quot;NTLM: connect %s[%s]/%s: %s&quot;</span>,
		   ai-&gt;ai_canonname ? ai-&gt;ai_canonname : server,
		   hbuf,
		   pbuf,
		   error_str);
	utils-&gt;free (error_str);
    }
    <span class="enscript-keyword">if</span> (s &lt; 0) {
	<span class="enscript-keyword">if</span> (getnameinfo(ai-&gt;ai_addr, ai-&gt;ai_addrlen, NULL, 0,
			pbuf, <span class="enscript-keyword">sizeof</span>(pbuf), NI_NUMERICSERV) != 0) {
		strcpy(pbuf, <span class="enscript-string">&quot;unknown&quot;</span>);
	}
	utils-&gt;log(NULL, SASL_LOG_ERR, <span class="enscript-string">&quot;NTLM: couldn't connect to %s/%s&quot;</span>,
		   ai-&gt;ai_canonname ? ai-&gt;ai_canonname : server, pbuf);
	freeaddrinfo(ai);
	<span class="enscript-keyword">return</span> -1;
    }

    freeaddrinfo(ai);

    <span class="enscript-comment">/*** send NetBIOS session request ***/</span>

    <span class="enscript-comment">/* get length of data */</span>
    pkt = <span class="enscript-keyword">sizeof</span>(called) + <span class="enscript-keyword">sizeof</span>(calling);

    <span class="enscript-comment">/* make sure length is less than 17 bits */</span>
    <span class="enscript-keyword">if</span> (pkt &gt;= (1 &lt;&lt; 17)) {
	closesocket(s);
	<span class="enscript-keyword">return</span> -1;
    }

    <span class="enscript-comment">/* prepend the packet type */</span>
    pkt |= (NBT_SESSION_REQUEST &lt;&lt; 24);
    pkt = htonl(pkt);

    <span class="enscript-comment">/* XXX should determine the real NetBIOS name */</span>
    make_netbios_name(server, called);
    make_netbios_name(client, calling);

    iov[0].iov_base = (<span class="enscript-type">void</span> *) &amp;pkt;
    iov[0].iov_len = <span class="enscript-keyword">sizeof</span>(pkt);
    iov[1].iov_base = called;
    iov[1].iov_len = <span class="enscript-keyword">sizeof</span>(called);
    iov[2].iov_base = calling;
    iov[2].iov_len = <span class="enscript-keyword">sizeof</span>(calling);

    rc = retry_writev(s, iov, N(iov));
    <span class="enscript-keyword">if</span> (rc == -1) {
	utils-&gt;log(NULL, SASL_LOG_ERR,
		   <span class="enscript-string">&quot;NTLM: error sending NetBIOS session request&quot;</span>);
	closesocket(s);
	<span class="enscript-keyword">return</span> -1;
    }

    rc = retry_read(s, (<span class="enscript-type">char</span> *) &amp;pkt, <span class="enscript-keyword">sizeof</span>(pkt));
    pkt = ntohl(pkt);
    <span class="enscript-keyword">if</span> (rc == -1 || pkt != (uint32) (NBT_POSITIVE_SESSION_RESP &lt;&lt; 24)) {
	<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> ec = NBT_ERR_UNSPECIFIED;
	<span class="enscript-type">char</span> *errstr;

	retry_read(s, (<span class="enscript-type">char</span> *) &amp;ec, <span class="enscript-keyword">sizeof</span>(ec));
	<span class="enscript-keyword">switch</span> (ec) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">NBT_ERR_NO_LISTEN_CALLED</span>:
	    errstr = <span class="enscript-string">&quot;Not listening on called name&quot;</span>;
	    <span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">NBT_ERR_NO_LISTEN_CALLING</span>:
	    errstr = <span class="enscript-string">&quot;Not listening for calling name&quot;</span>;
	    <span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">NBT_ERR_CALLED_NOT_PRESENT</span>:
	    errstr = <span class="enscript-string">&quot;Called name not present&quot;</span>;
	    <span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">NBT_ERR_INSUFFICIENT_RESRC</span>:
	    errstr = <span class="enscript-string">&quot;Called name present, but insufficient resources&quot;</span>;
	    <span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
	    errstr = <span class="enscript-string">&quot;Unspecified error&quot;</span>;
	}
	utils-&gt;log(NULL, SASL_LOG_ERR,
		   <span class="enscript-string">&quot;NTLM: negative NetBIOS session response: %s&quot;</span>, errstr);
	closesocket(s);
	<span class="enscript-keyword">return</span> -1;
    }

    <span class="enscript-keyword">return</span> s;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">smb_negotiate_protocol</span>(<span class="enscript-type">const</span> sasl_utils_t *utils,
				  server_context_t *text, <span class="enscript-type">char</span> **domain)
{
    SMB_Header hdr;
    SMB_NegProt_Resp resp;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> hbuf[SMB_HDR_SIZE], *p;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> wordcount = 0;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> bc[<span class="enscript-keyword">sizeof</span>(uint16)];
    uint16 bytecount;
    uint32 len, nl;
    <span class="enscript-type">int</span> n_dialects = N(SMB_DIALECTS);
    <span class="enscript-type">struct</span> iovec iov[4+N(SMB_DIALECTS)];
    size_t i, n;
    <span class="enscript-type">int</span> rc;
    pid_t current_pid;

    <span class="enscript-comment">/*** create a negotiate protocol request ***/</span>

    <span class="enscript-comment">/* create a header */</span>
    memset(&amp;hdr, 0, <span class="enscript-keyword">sizeof</span>(hdr));
    hdr.command = SMB_COM_NEGOTIATE_PROTOCOL;
#<span class="enscript-reference">if</span> 0
    hdr.flags2 = SMB_FLAGS2_ERR_STATUS;
    <span class="enscript-keyword">if</span> (text-&gt;flags &amp; NTLM_USE_UNICODE) hdr.flags2 |= SMB_FLAGS2_UNICODE;
#<span class="enscript-reference">endif</span>
    current_pid = getpid();
    <span class="enscript-keyword">if</span> (<span class="enscript-keyword">sizeof</span>(current_pid) &lt;= 2) {
	hdr.pid = (uint16) current_pid;
	hdr.PidHigh = 0;
    } <span class="enscript-keyword">else</span> {
	hdr.pid = (uint16) (((uint32) current_pid) &amp; 0xFFFF);
	hdr.PidHigh = (uint16) (((uint32) current_pid) &gt;&gt; 16);
    }

    load_smb_header(hbuf, &amp;hdr);

    <span class="enscript-comment">/* put together all of the pieces of the request */</span>
    n = 0;
    iov[n].iov_base = (<span class="enscript-type">void</span> *) &amp;nl;
    iov[n++].iov_len = <span class="enscript-keyword">sizeof</span>(len);
    iov[n].iov_base = hbuf;
    iov[n++].iov_len = SMB_HDR_SIZE;
    iov[n].iov_base = &amp;wordcount;
    iov[n++].iov_len = <span class="enscript-keyword">sizeof</span>(wordcount);
    iov[n].iov_base = (<span class="enscript-type">void</span> *) &amp;bc;
    iov[n++].iov_len = <span class="enscript-keyword">sizeof</span>(bc);

    <span class="enscript-comment">/* add our supported dialects */</span>
    <span class="enscript-keyword">for</span> (i = 0; i &lt; n_dialects; i++) {
	iov[n].iov_base = (<span class="enscript-type">char</span> *) SMB_DIALECTS[i];
	iov[n++].iov_len = (<span class="enscript-type">long</span>) strlen(SMB_DIALECTS[i]) + 1;
    }

    <span class="enscript-comment">/* total up the lengths */</span>
    len = bytecount = 0;
    <span class="enscript-keyword">for</span> (i = 1; i &lt; 4; i++) len += iov[i].iov_len;
    <span class="enscript-keyword">for</span> (i = 4; i &lt; n; i++) bytecount += (uint16) iov[i].iov_len;
    len += bytecount;
    nl = htonl(len);
    htois((<span class="enscript-type">char</span> *) &amp;bc, bytecount);

    <span class="enscript-comment">/* send it */</span>
    rc = retry_writev(text-&gt;sock, iov, n);
    <span class="enscript-keyword">if</span> (rc == -1) {
	utils-&gt;log(NULL, SASL_LOG_ERR,
		   <span class="enscript-string">&quot;NTLM: error sending NEGPROT request&quot;</span>);
	<span class="enscript-keyword">return</span> SASL_FAIL;
    }

    <span class="enscript-comment">/*** read the negotiate protocol response ***/</span>

    <span class="enscript-comment">/* read the total length */</span>
    rc = retry_read(text-&gt;sock, (<span class="enscript-type">char</span> *) &amp;nl, <span class="enscript-keyword">sizeof</span>(nl));
    <span class="enscript-keyword">if</span> (rc &lt; (<span class="enscript-type">int</span>) <span class="enscript-keyword">sizeof</span>(nl)) {
	utils-&gt;log(NULL, SASL_LOG_ERR,
		   <span class="enscript-string">&quot;NTLM: error reading NEGPROT response length&quot;</span>);
	<span class="enscript-keyword">return</span> SASL_FAIL;
    }

    <span class="enscript-comment">/* read the data */</span>
    len = ntohl(nl);
    <span class="enscript-keyword">if</span> (_plug_buf_alloc(utils, &amp;text-&gt;out_buf, &amp;text-&gt;out_buf_len,
			len) != SASL_OK) {
	SETERROR(utils, <span class="enscript-string">&quot;cannot allocate NTLM NEGPROT response buffer&quot;</span>);
	<span class="enscript-keyword">return</span> SASL_NOMEM;
    }

    rc = retry_read(text-&gt;sock, text-&gt;out_buf, len);
    <span class="enscript-keyword">if</span> (rc &lt; (<span class="enscript-type">int</span>) len) {
	utils-&gt;log(NULL, SASL_LOG_ERR,
		   <span class="enscript-string">&quot;NTLM: error reading NEGPROT response&quot;</span>);
	<span class="enscript-keyword">return</span> SASL_FAIL;
    }
    p = text-&gt;out_buf;

    <span class="enscript-comment">/* parse the header */</span>
    <span class="enscript-keyword">if</span> (len &lt; SMB_HDR_SIZE) {
	utils-&gt;log(NULL, SASL_LOG_ERR,
		   <span class="enscript-string">&quot;NTLM: not enough data for NEGPROT response header&quot;</span>);
	<span class="enscript-keyword">return</span> SASL_FAIL;
    }
    unload_smb_header(p, &amp;hdr);
    p += SMB_HDR_SIZE;
    len -= SMB_HDR_SIZE;

    <span class="enscript-comment">/* sanity check the header */</span>
    <span class="enscript-keyword">if</span> (memcmp(hdr.protocol, SMB_HDR_PROTOCOL, 4)	 <span class="enscript-comment">/* correct protocol */</span>
	|| hdr.command != SMB_COM_NEGOTIATE_PROTOCOL <span class="enscript-comment">/* correct command */</span>
	|| hdr.status				 <span class="enscript-comment">/* no errors */</span>
	|| !(hdr.flags &amp; SMB_FLAGS_SERVER_TO_REDIR)) { <span class="enscript-comment">/* response */</span>
	utils-&gt;log(NULL, SASL_LOG_ERR,
		   <span class="enscript-string">&quot;NTLM: error in NEGPROT response header: %ld&quot;</span>,
		   hdr.status);
	<span class="enscript-keyword">return</span> SASL_FAIL;
    }

    <span class="enscript-comment">/* get the wordcount */</span>
    <span class="enscript-keyword">if</span> (len &lt; 1) {
	utils-&gt;log(NULL, SASL_LOG_ERR,
		   <span class="enscript-string">&quot;NTLM: not enough data for NEGPROT response wordcount&quot;</span>);
	<span class="enscript-keyword">return</span> SASL_FAIL;
    }
    wordcount = *p++;
    len--;

    <span class="enscript-comment">/* parse the parameters */</span>
    <span class="enscript-keyword">if</span> (wordcount != SMB_NEGPROT_RESP_SIZE / <span class="enscript-keyword">sizeof</span>(uint16)) {
	utils-&gt;log(NULL, SASL_LOG_ERR,
		   <span class="enscript-string">&quot;NTLM: incorrect NEGPROT wordcount for NT LM 0.12&quot;</span>);
	<span class="enscript-keyword">return</span> SASL_FAIL;
    }
    unload_negprot_resp(p, &amp;resp);
    p += SMB_NEGPROT_RESP_SIZE;
    len -= SMB_NEGPROT_RESP_SIZE;

    <span class="enscript-comment">/* sanity check the parameters */</span>
    <span class="enscript-keyword">if</span> (resp.dialect_index != 0
	|| !(resp.security_mode &amp; SMB_SECURITY_MODE_USER)
	|| !(resp.security_mode &amp; SMB_SECURITY_MODE_ENCRYPT)
	|| resp.security_mode &amp; SMB_SECURITY_MODE_SIGN_REQ
	|| resp.capabilities &amp; SMB_CAP_EXTENDED_SECURITY
	|| resp.encryption_key_length != NTLM_NONCE_LENGTH) {
	utils-&gt;log(NULL, SASL_LOG_ERR,
		   <span class="enscript-string">&quot;NTLM: error in NEGPROT response parameters&quot;</span>);
	<span class="enscript-keyword">return</span> SASL_FAIL;
    }

    <span class="enscript-comment">/* get the bytecount */</span>
    <span class="enscript-keyword">if</span> (len &lt; 2) {
	utils-&gt;log(NULL, SASL_LOG_ERR,
		   <span class="enscript-string">&quot;NTLM: not enough data for NEGPROT response bytecount&quot;</span>);
	<span class="enscript-keyword">return</span> SASL_FAIL;
    }
    bytecount = itohs(p);
    p += 2;
    len -= 2;
    <span class="enscript-keyword">if</span> (len != bytecount) {
	utils-&gt;log(NULL, SASL_LOG_ERR,
		   <span class="enscript-string">&quot;NTLM: incorrect bytecount for NEGPROT response data&quot;</span>);
	<span class="enscript-keyword">return</span> SASL_FAIL;
    }

    <span class="enscript-comment">/* parse the data */</span>
    memcpy(text-&gt;nonce, p, resp.encryption_key_length);
    p += resp.encryption_key_length;
    len -= resp.encryption_key_length;

    <span class="enscript-comment">/* if client asked for target, send domain */</span>
    <span class="enscript-keyword">if</span> (text-&gt;flags &amp; NTLM_ASK_TARGET) {
	*domain = utils-&gt;malloc(len);
	<span class="enscript-keyword">if</span> (domain == NULL) {
	    MEMERROR(utils);
	    <span class="enscript-keyword">return</span> SASL_NOMEM;
	}
	memcpy(*domain, p, len);
	from_unicode(*domain, *domain, len);

	text-&gt;flags |= NTLM_TARGET_IS_DOMAIN;
    }

    <span class="enscript-keyword">return</span> SASL_OK;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">smb_session_setup</span>(<span class="enscript-type">const</span> sasl_utils_t *utils, server_context_t *text,
			     <span class="enscript-type">const</span> <span class="enscript-type">char</span> *authid, <span class="enscript-type">char</span> *domain,
			     <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *lm_resp, <span class="enscript-type">unsigned</span> lm_resp_len,
			     <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *nt_resp, <span class="enscript-type">unsigned</span> nt_resp_len)
{
    SMB_Header hdr;
    SMB_SessionSetup setup;
    SMB_SessionSetup_Resp resp;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> hbuf[SMB_HDR_SIZE], sbuf[SMB_SESSION_SETUP_SIZE], *p;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> wordcount = SMB_SESSION_SETUP_SIZE / <span class="enscript-keyword">sizeof</span>(uint16);
    <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> bc[<span class="enscript-keyword">sizeof</span>(uint16)];
    uint16 bytecount;
    uint32 len, nl;
    <span class="enscript-type">struct</span> iovec iov[12];
    size_t i, n;
    <span class="enscript-type">int</span> rc;
#<span class="enscript-reference">if</span> (<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">WIN32</span>) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__APPLE__</span>))
    <span class="enscript-type">char</span> osbuf[80];
#<span class="enscript-reference">else</span>
    <span class="enscript-type">char</span> osbuf[2*SYS_NMLN+2];
#<span class="enscript-reference">endif</span>
    <span class="enscript-type">char</span> lanman[20];
    pid_t current_pid;

    <span class="enscript-comment">/*** create a session setup request ***/</span>

    <span class="enscript-comment">/* create a header */</span>
    memset(&amp;hdr, 0, <span class="enscript-keyword">sizeof</span>(hdr));
    hdr.command = SMB_COM_SESSION_SETUP_ANDX;
#<span class="enscript-reference">if</span> 0
    hdr.flags2 = SMB_FLAGS2_ERR_STATUS;
    <span class="enscript-keyword">if</span> (text-&gt;flags &amp; NTLM_USE_UNICODE) hdr.flags2 |= SMB_FLAGS2_UNICODE;
#<span class="enscript-reference">endif</span>
    current_pid = getpid();
    <span class="enscript-keyword">if</span> (<span class="enscript-keyword">sizeof</span>(current_pid) &lt;= 2) {
	hdr.pid = (uint16) current_pid;
	hdr.PidHigh = 0;
    } <span class="enscript-keyword">else</span> {
	hdr.pid = (uint16) (((uint32) current_pid) &amp; 0xFFFF);
	hdr.PidHigh = (uint16) (((uint32) current_pid) &gt;&gt; 16);
    }

    load_smb_header(hbuf, &amp;hdr);

    <span class="enscript-comment">/* create a the setup parameters */</span>
    memset(&amp;setup, 0, <span class="enscript-keyword">sizeof</span>(setup));
    setup.andx_command = SMB_COM_NONE;
    setup.max_buffer_size = 0xFFFF;
    <span class="enscript-keyword">if</span> (lm_resp) setup.case_insensitive_passwd_len = lm_resp_len;
    <span class="enscript-keyword">if</span> (nt_resp) setup.case_sensitive_passwd_len = nt_resp_len;
#<span class="enscript-reference">if</span> 0
    <span class="enscript-keyword">if</span> (text-&gt;flags &amp; NTLM_USE_UNICODE)
	setup.capabilities = SMB_CAP_UNICODE;
#<span class="enscript-reference">endif</span>
    load_session_setup(sbuf, &amp;setup);

    _plug_snprintf_os_info (osbuf, <span class="enscript-keyword">sizeof</span>(osbuf));

    snprintf(lanman, <span class="enscript-keyword">sizeof</span>(lanman), <span class="enscript-string">&quot;Cyrus SASL %u.%u.%u&quot;</span>,
	     SASL_VERSION_MAJOR, SASL_VERSION_MINOR,
	     SASL_VERSION_STEP);

    <span class="enscript-comment">/* put together all of the pieces of the request */</span>
    n = 0;
    iov[n].iov_base = (<span class="enscript-type">void</span> *) &amp;nl;
    iov[n++].iov_len = <span class="enscript-keyword">sizeof</span>(len);
    iov[n].iov_base = hbuf;
    iov[n++].iov_len = SMB_HDR_SIZE;
    iov[n].iov_base = &amp;wordcount;
    iov[n++].iov_len = <span class="enscript-keyword">sizeof</span>(wordcount);
    iov[n].iov_base = sbuf;
    iov[n++].iov_len = SMB_SESSION_SETUP_SIZE;
    iov[n].iov_base = (<span class="enscript-type">void</span> *) &amp;bc;
    iov[n++].iov_len = <span class="enscript-keyword">sizeof</span>(bc);
    <span class="enscript-keyword">if</span> (lm_resp) {
	iov[n].iov_base = lm_resp;
	iov[n++].iov_len = NTLM_RESP_LENGTH;
    }
    <span class="enscript-keyword">if</span> (nt_resp) {
	iov[n].iov_base = nt_resp;
	iov[n++].iov_len = NTLM_RESP_LENGTH;
    }
    iov[n].iov_base = (<span class="enscript-type">char</span>*) authid;
    iov[n++].iov_len = (<span class="enscript-type">long</span>) strlen(authid) + 1;
    <span class="enscript-keyword">if</span> (!domain) domain = <span class="enscript-string">&quot;&quot;</span>;
    iov[n].iov_base = domain;
    iov[n++].iov_len = (<span class="enscript-type">long</span>) strlen(domain) + 1;
    iov[n].iov_base = osbuf;
    iov[n++].iov_len = (<span class="enscript-type">long</span>) strlen(osbuf) + 1;
    iov[n].iov_base = lanman;
    iov[n++].iov_len = (<span class="enscript-type">long</span>) strlen(lanman) + 1;

    <span class="enscript-comment">/* total up the lengths */</span>
    len = bytecount = 0;
    <span class="enscript-keyword">for</span> (i = 1; i &lt; 5; i++) len += iov[i].iov_len;
    <span class="enscript-keyword">for</span> (i = 5; i &lt; n; i++) bytecount += (uint16) iov[i].iov_len;
    len += bytecount;
    nl = htonl(len);
    htois((<span class="enscript-type">char</span> *) &amp;bc, bytecount);

    <span class="enscript-comment">/* send it */</span>
    rc = retry_writev(text-&gt;sock, iov, n);
    <span class="enscript-keyword">if</span> (rc == -1) {
	utils-&gt;log(NULL, SASL_LOG_ERR,
		   <span class="enscript-string">&quot;NTLM: error sending SESSIONSETUP request&quot;</span>);
	<span class="enscript-keyword">return</span> SASL_FAIL;
    }

    <span class="enscript-comment">/*** read the session setup response ***/</span>

    <span class="enscript-comment">/* read the total length */</span>
    rc = retry_read(text-&gt;sock, (<span class="enscript-type">char</span> *) &amp;nl, <span class="enscript-keyword">sizeof</span>(nl));
    <span class="enscript-keyword">if</span> (rc &lt; (<span class="enscript-type">int</span>) <span class="enscript-keyword">sizeof</span>(nl)) {
	utils-&gt;log(NULL, SASL_LOG_ERR,
		   <span class="enscript-string">&quot;NTLM: error reading SESSIONSETUP response length&quot;</span>);
	<span class="enscript-keyword">return</span> SASL_FAIL;
    }

    <span class="enscript-comment">/* read the data */</span>
    len = ntohl(nl);
    <span class="enscript-keyword">if</span> (_plug_buf_alloc(utils, &amp;text-&gt;out_buf, &amp;text-&gt;out_buf_len,
			len) != SASL_OK) {
	SETERROR(utils,
		 <span class="enscript-string">&quot;cannot allocate NTLM SESSIONSETUP response buffer&quot;</span>);
	<span class="enscript-keyword">return</span> SASL_NOMEM;
    }

    rc = retry_read(text-&gt;sock, text-&gt;out_buf, len);
    <span class="enscript-keyword">if</span> (rc &lt; (<span class="enscript-type">int</span>) len) {
	utils-&gt;log(NULL, SASL_LOG_ERR,
		   <span class="enscript-string">&quot;NTLM: error reading SESSIONSETUP response&quot;</span>);
	<span class="enscript-keyword">return</span> SASL_FAIL;
    }
    p = text-&gt;out_buf;

    <span class="enscript-comment">/* parse the header */</span>
    <span class="enscript-keyword">if</span> (len &lt; SMB_HDR_SIZE) {
	utils-&gt;log(NULL, SASL_LOG_ERR,
		   <span class="enscript-string">&quot;NTLM: not enough data for SESSIONSETUP response header&quot;</span>);
	<span class="enscript-keyword">return</span> SASL_FAIL;
    }
    unload_smb_header(p, &amp;hdr);
    p += SMB_HDR_SIZE;
    len -= SMB_HDR_SIZE;

    <span class="enscript-comment">/* sanity check the header */</span>
    <span class="enscript-keyword">if</span> (memcmp(hdr.protocol, SMB_HDR_PROTOCOL, 4)	<span class="enscript-comment">/* correct protocol */</span>
	|| hdr.command != SMB_COM_SESSION_SETUP_ANDX	<span class="enscript-comment">/* correct command */</span>
	|| !(hdr.flags &amp; SMB_FLAGS_SERVER_TO_REDIR)) {	<span class="enscript-comment">/* response */</span>
	utils-&gt;log(NULL, SASL_LOG_ERR,
		   <span class="enscript-string">&quot;NTLM: error in SESSIONSETUP response header&quot;</span>);
	<span class="enscript-keyword">return</span> SASL_FAIL;
    }

    <span class="enscript-comment">/* check auth success */</span>
    <span class="enscript-keyword">if</span> (hdr.status) {
	utils-&gt;log(NULL, SASL_LOG_ERR,
		   <span class="enscript-string">&quot;NTLM: auth failure: %ld&quot;</span>, hdr.status);
	<span class="enscript-keyword">return</span> SASL_BADAUTH;
    }

    <span class="enscript-comment">/* get the wordcount */</span>
    <span class="enscript-keyword">if</span> (len &lt; 1) {
	utils-&gt;log(NULL, SASL_LOG_ERR,
		   <span class="enscript-string">&quot;NTLM: not enough data for SESSIONSETUP response wordcount&quot;</span>);
	<span class="enscript-keyword">return</span> SASL_FAIL;
    }
    wordcount = *p++;
    len--;

    <span class="enscript-comment">/* parse the parameters */</span>
    <span class="enscript-keyword">if</span> (wordcount &lt; SMB_SESSION_SETUP_RESP_SIZE / <span class="enscript-keyword">sizeof</span>(uint16)) {
	utils-&gt;log(NULL, SASL_LOG_ERR,
		   <span class="enscript-string">&quot;NTLM: incorrect SESSIONSETUP wordcount&quot;</span>);
	<span class="enscript-keyword">return</span> SASL_FAIL;
    }
    unload_session_setup_resp(p, &amp;resp);

    <span class="enscript-comment">/* check auth success */</span>
    <span class="enscript-keyword">if</span> (resp.action &amp; SMB_REQUEST_MODE_GUEST) {
	utils-&gt;log(NULL, SASL_LOG_ERR,
		   <span class="enscript-string">&quot;NTLM: authenticated as guest&quot;</span>);
	<span class="enscript-keyword">return</span> SASL_BADAUTH;
    }

    <span class="enscript-keyword">return</span> SASL_OK;
}

<span class="enscript-comment">/*
 * Create a server challenge message (type 2) consisting of:
 *
 * signature (8 bytes)
 * message type (uint32)
 * target name (buffer)
 * flags (uint32)
 * challenge (8 bytes)
 * context (8 bytes)
 * target info (buffer)
 * data
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">create_challenge</span>(<span class="enscript-type">const</span> sasl_utils_t *utils,
			    <span class="enscript-type">char</span> **buf, <span class="enscript-type">unsigned</span> *buflen,
			    <span class="enscript-type">const</span> <span class="enscript-type">char</span> *target, uint32 flags,
			    <span class="enscript-type">const</span> u_char *nonce, <span class="enscript-type">unsigned</span> *outlen)
{
    uint32 offset = NTLM_TYPE2_DATA_OFFSET;
    u_char *base;

    <span class="enscript-keyword">if</span> (!nonce) {
	SETERROR(utils, <span class="enscript-string">&quot;need nonce for NTLM challenge&quot;</span>);
	<span class="enscript-keyword">return</span> SASL_FAIL;
    }

    *outlen = offset + 2 * xstrlen(target);

    <span class="enscript-keyword">if</span> (_plug_buf_alloc(utils, buf, buflen, *outlen) != SASL_OK) {
	SETERROR(utils, <span class="enscript-string">&quot;cannot allocate NTLM challenge&quot;</span>);
	<span class="enscript-keyword">return</span> SASL_NOMEM;
    }

    base = *buf;
    memset(base, 0, *outlen);
    memcpy(base + NTLM_SIG_OFFSET, NTLM_SIGNATURE, <span class="enscript-keyword">sizeof</span>(NTLM_SIGNATURE));
    htoil(base + NTLM_TYPE_OFFSET, NTLM_TYPE_CHALLENGE);
    load_buffer(base + NTLM_TYPE2_TARGET_OFFSET,
		ucase(target, 0), (uint16) xstrlen(target), flags &amp; NTLM_USE_UNICODE,
		base, &amp;offset);
    htoil(base + NTLM_TYPE2_FLAGS_OFFSET, flags);
    memcpy(base + NTLM_TYPE2_CHALLENGE_OFFSET, nonce, NTLM_NONCE_LENGTH);

    <span class="enscript-keyword">return</span> SASL_OK;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">ntlm_server_mech_new</span>(<span class="enscript-type">void</span> *glob_context __attribute__((unused)), 
				sasl_server_params_t *sparams,
				<span class="enscript-type">const</span> <span class="enscript-type">char</span> *challenge __attribute__((unused)),
				<span class="enscript-type">unsigned</span> challen __attribute__((unused)),
				<span class="enscript-type">void</span> **conn_context)
{
    server_context_t *text;
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> *serv;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> len;
    SOCKET sock = (SOCKET) -1;

    sparams-&gt;utils-&gt;getopt(sparams-&gt;utils-&gt;getopt_context,
			   <span class="enscript-string">&quot;NTLM&quot;</span>, <span class="enscript-string">&quot;ntlm_server&quot;</span>, &amp;serv, &amp;len);
    <span class="enscript-keyword">if</span> (serv) {
	<span class="enscript-comment">/* try to start a NetBIOS session with the server */</span>
	sock = smb_connect_server(sparams-&gt;utils, sparams-&gt;serverFQDN, serv);
	<span class="enscript-keyword">if</span> (sock == (SOCKET) -1) <span class="enscript-keyword">return</span> SASL_UNAVAIL;
    }
    
    <span class="enscript-comment">/* holds state are in */</span>
    text = sparams-&gt;utils-&gt;malloc(<span class="enscript-keyword">sizeof</span>(server_context_t));
    <span class="enscript-keyword">if</span> (text == NULL) {
	MEMERROR( sparams-&gt;utils );
	<span class="enscript-keyword">return</span> SASL_NOMEM;
    }
    
    memset(text, 0, <span class="enscript-keyword">sizeof</span>(server_context_t));
    
    text-&gt;state = 1;
    text-&gt;sock = sock;
    
    *conn_context = text;
    
    <span class="enscript-keyword">return</span> SASL_OK;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">ntlm_server_mech_step1</span>(server_context_t *text,
				  sasl_server_params_t *sparams,
				  <span class="enscript-type">const</span> <span class="enscript-type">char</span> *clientin,
				  <span class="enscript-type">unsigned</span> clientinlen,
				  <span class="enscript-type">const</span> <span class="enscript-type">char</span> **serverout,
				  <span class="enscript-type">unsigned</span> *serveroutlen,
				  sasl_out_params_t *oparams __attribute__((unused)))
{
    <span class="enscript-type">char</span> *domain = NULL;
    <span class="enscript-type">int</span> result;

    <span class="enscript-keyword">if</span> (!clientin || clientinlen &lt; NTLM_TYPE1_MINSIZE ||
	memcmp(clientin, NTLM_SIGNATURE, <span class="enscript-keyword">sizeof</span>(NTLM_SIGNATURE)) ||
	itohl(clientin + NTLM_TYPE_OFFSET) != NTLM_TYPE_REQUEST) {
	SETERROR(sparams-&gt;utils, <span class="enscript-string">&quot;client didn't issue valid NTLM request&quot;</span>);
	<span class="enscript-keyword">return</span> SASL_BADPROT;
    }

    text-&gt;flags = itohl(clientin + NTLM_TYPE1_FLAGS_OFFSET);
    sparams-&gt;utils-&gt;log(NULL, SASL_LOG_DEBUG,
			<span class="enscript-string">&quot;client flags: %x&quot;</span>, text-&gt;flags);

    text-&gt;flags &amp;= NTLM_FLAGS_MASK; <span class="enscript-comment">/* mask off the bits we don't support */</span>

    <span class="enscript-comment">/* if client can do Unicode, turn off ASCII */</span>
    <span class="enscript-keyword">if</span> (text-&gt;flags &amp; NTLM_USE_UNICODE) text-&gt;flags &amp;= ~NTLM_USE_ASCII;

    <span class="enscript-keyword">if</span> (text-&gt;sock == -1) {
	<span class="enscript-comment">/* generate challenge internally */</span>

	<span class="enscript-comment">/* if client asked for target, use FQDN as server target */</span>
	<span class="enscript-keyword">if</span> (text-&gt;flags &amp; NTLM_ASK_TARGET) {
	    result = _plug_strdup(sparams-&gt;utils, sparams-&gt;serverFQDN,
			      &amp;domain, NULL);
	    <span class="enscript-keyword">if</span> (result != SASL_OK) <span class="enscript-keyword">return</span> result;

	    text-&gt;flags |= NTLM_TARGET_IS_SERVER;
	}

	<span class="enscript-comment">/* generate a nonce */</span>
	sparams-&gt;utils-&gt;rand(sparams-&gt;utils-&gt;rpool,
			     (<span class="enscript-type">char</span> *) text-&gt;nonce, NTLM_NONCE_LENGTH);
    }
    <span class="enscript-keyword">else</span> {
	<span class="enscript-comment">/* proxy the response/challenge */</span>
	result = smb_negotiate_protocol(sparams-&gt;utils, text, &amp;domain);
	<span class="enscript-keyword">if</span> (result != SASL_OK) <span class="enscript-keyword">goto</span> <span class="enscript-reference">cleanup</span>;
    }

    result = create_challenge(sparams-&gt;utils,
			      &amp;text-&gt;out_buf, &amp;text-&gt;out_buf_len,
			      domain, text-&gt;flags, text-&gt;nonce, serveroutlen);
    <span class="enscript-keyword">if</span> (result != SASL_OK) <span class="enscript-keyword">goto</span> <span class="enscript-reference">cleanup</span>;

    *serverout = text-&gt;out_buf;

    text-&gt;state = 2;
    
    result = SASL_CONTINUE;

  <span class="enscript-reference">cleanup</span>:
    <span class="enscript-keyword">if</span> (domain) sparams-&gt;utils-&gt;free(domain);

    <span class="enscript-keyword">return</span> result;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">ntlm_server_mech_step2</span>(server_context_t *text,
				  sasl_server_params_t *sparams,
				  <span class="enscript-type">const</span> <span class="enscript-type">char</span> *clientin,
				  <span class="enscript-type">unsigned</span> clientinlen,
				  <span class="enscript-type">const</span> <span class="enscript-type">char</span> **serverout __attribute__((unused)),
				  <span class="enscript-type">unsigned</span> *serveroutlen __attribute__((unused)),
				  sasl_out_params_t *oparams)
{
    <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *lm_resp = NULL, *nt_resp = NULL;
    <span class="enscript-type">char</span> *domain = NULL, *authid = NULL;
    <span class="enscript-type">unsigned</span> lm_resp_len, nt_resp_len, domain_len, authid_len;
    <span class="enscript-type">int</span> result;

    <span class="enscript-keyword">if</span> (!clientin || clientinlen &lt; NTLM_TYPE3_MINSIZE ||
	memcmp(clientin, NTLM_SIGNATURE, <span class="enscript-keyword">sizeof</span>(NTLM_SIGNATURE)) ||
	itohl(clientin + NTLM_TYPE_OFFSET) != NTLM_TYPE_RESPONSE) {
	SETERROR(sparams-&gt;utils, <span class="enscript-string">&quot;client didn't issue valid NTLM response&quot;</span>);
	<span class="enscript-keyword">return</span> SASL_BADPROT;
    }

    result = unload_buffer(sparams-&gt;utils, (<span class="enscript-type">const</span> u_char *)clientin + NTLM_TYPE3_LMRESP_OFFSET,
			   (u_char **) &amp;lm_resp, &amp;lm_resp_len, 0,
			   (<span class="enscript-type">const</span> u_char *)clientin, clientinlen);
    <span class="enscript-keyword">if</span> (result != SASL_OK) <span class="enscript-keyword">goto</span> <span class="enscript-reference">cleanup</span>;

    result = unload_buffer(sparams-&gt;utils, (<span class="enscript-type">const</span> u_char *)clientin + NTLM_TYPE3_NTRESP_OFFSET,
			   (u_char **) &amp;nt_resp, &amp;nt_resp_len, 0,
			   (<span class="enscript-type">const</span> u_char *)clientin, clientinlen);
    <span class="enscript-keyword">if</span> (result != SASL_OK) <span class="enscript-keyword">goto</span> <span class="enscript-reference">cleanup</span>;

    result = unload_buffer(sparams-&gt;utils, (<span class="enscript-type">const</span> u_char *)clientin + NTLM_TYPE3_DOMAIN_OFFSET,
			   (u_char **) &amp;domain, &amp;domain_len,
			   text-&gt;flags &amp; NTLM_USE_UNICODE,
			   (<span class="enscript-type">const</span> u_char *)clientin, clientinlen);
    <span class="enscript-keyword">if</span> (result != SASL_OK) <span class="enscript-keyword">goto</span> <span class="enscript-reference">cleanup</span>;

    result = unload_buffer(sparams-&gt;utils, (<span class="enscript-type">const</span> u_char *)clientin + NTLM_TYPE3_USER_OFFSET,
			   (u_char **) &amp;authid, &amp;authid_len,
			   text-&gt;flags &amp; NTLM_USE_UNICODE,
			   (<span class="enscript-type">const</span> u_char *)clientin, clientinlen);
    <span class="enscript-keyword">if</span> (result != SASL_OK) <span class="enscript-keyword">goto</span> <span class="enscript-reference">cleanup</span>;

    <span class="enscript-comment">/* require at least one response and an authid */</span>
    <span class="enscript-keyword">if</span> ((!lm_resp &amp;&amp; !nt_resp) ||
	(lm_resp &amp;&amp; lm_resp_len &lt; NTLM_RESP_LENGTH) ||
	(nt_resp &amp;&amp; nt_resp_len &lt; NTLM_RESP_LENGTH) ||
	!authid) {
	SETERROR(sparams-&gt;utils, <span class="enscript-string">&quot;client issued incorrect/nonexistent responses&quot;</span>);
	result = SASL_BADPROT;
	<span class="enscript-keyword">goto</span> <span class="enscript-reference">cleanup</span>;
    }

    sparams-&gt;utils-&gt;log(NULL, SASL_LOG_DEBUG,
			<span class="enscript-string">&quot;client user: %s&quot;</span>, authid);
    <span class="enscript-keyword">if</span> (domain) sparams-&gt;utils-&gt;log(NULL, SASL_LOG_DEBUG,
				    <span class="enscript-string">&quot;client domain: %s&quot;</span>, domain);

    <span class="enscript-keyword">if</span> (text-&gt;sock == -1) {
	<span class="enscript-comment">/* verify the response internally */</span>

	sasl_secret_t *password = NULL;
	size_t pass_len;
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> *password_request[] = { SASL_AUX_PASSWORD,
				       NULL };
	<span class="enscript-type">struct</span> propval auxprop_values[2];
	<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> hash[NTLM_HASH_LENGTH];
	<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> resp[NTLM_RESP_LENGTH];

	<span class="enscript-comment">/* fetch user's password */</span>
	result = sparams-&gt;utils-&gt;prop_request(sparams-&gt;propctx, password_request);
	<span class="enscript-keyword">if</span> (result != SASL_OK) <span class="enscript-keyword">goto</span> <span class="enscript-reference">cleanup</span>;
    
	<span class="enscript-comment">/* this will trigger the getting of the aux properties */</span>
	result = sparams-&gt;canon_user(sparams-&gt;utils-&gt;conn, authid, authid_len,
				     SASL_CU_AUTHID | SASL_CU_AUTHZID, oparams);
	<span class="enscript-keyword">if</span> (result != SASL_OK) <span class="enscript-keyword">goto</span> <span class="enscript-reference">cleanup</span>;

	result = sparams-&gt;utils-&gt;prop_getnames(sparams-&gt;propctx,
					       password_request,
					       auxprop_values);
	<span class="enscript-keyword">if</span> (result &lt; 0 ||
	    (!auxprop_values[0].name || !auxprop_values[0].values)) {
	    <span class="enscript-comment">/* We didn't find this username */</span>
	    SETERROR(sparams-&gt;utils, <span class="enscript-string">&quot;no secret in database&quot;</span>);
	    result = sparams-&gt;transition ? SASL_TRANS : SASL_NOUSER;
	    <span class="enscript-keyword">goto</span> <span class="enscript-reference">cleanup</span>;
	}
    
	pass_len = strlen(auxprop_values[0].values[0]);
	<span class="enscript-keyword">if</span> (pass_len == 0) {
	    SETERROR(sparams-&gt;utils, <span class="enscript-string">&quot;empty secret&quot;</span>);
	    result = SASL_FAIL;
	    <span class="enscript-keyword">goto</span> <span class="enscript-reference">cleanup</span>;
	}

	password = sparams-&gt;utils-&gt;malloc(<span class="enscript-keyword">sizeof</span>(sasl_secret_t) + pass_len);
	<span class="enscript-keyword">if</span> (!password) {
	    result = SASL_NOMEM;
	    <span class="enscript-keyword">goto</span> <span class="enscript-reference">cleanup</span>;
	}
	
	password-&gt;len = pass_len;
	strncpy((<span class="enscript-type">char</span> *)password-&gt;data, auxprop_values[0].values[0], pass_len + 1);

	<span class="enscript-comment">/* erase the plaintext password */</span>
	sparams-&gt;utils-&gt;prop_erase(sparams-&gt;propctx, password_request[0]);

	<span class="enscript-comment">/* calculate our own response(s) and compare with client's */</span>
	result = SASL_OK;
	<span class="enscript-keyword">if</span> (nt_resp &amp;&amp; (nt_resp_len &gt; NTLM_RESP_LENGTH)) {
	    <span class="enscript-comment">/* Try NTv2 response */</span>
	    sparams-&gt;utils-&gt;log(NULL, SASL_LOG_DEBUG,
				<span class="enscript-string">&quot;calculating NTv2 response&quot;</span>);
	    V2(resp, password, authid, domain, text-&gt;nonce,
	       lm_resp + MD5_DIGEST_LENGTH, nt_resp_len - MD5_DIGEST_LENGTH,
	       sparams-&gt;utils, &amp;text-&gt;out_buf, &amp;text-&gt;out_buf_len,
	       &amp;result);

	    <span class="enscript-comment">/* No need to compare the blob */</span>
	    <span class="enscript-keyword">if</span> (memcmp(nt_resp, resp, MD5_DIGEST_LENGTH)) {
		SETERROR(sparams-&gt;utils, <span class="enscript-string">&quot;incorrect NTLMv2 response&quot;</span>);
		result = SASL_BADAUTH;
	    }
	}
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (nt_resp) {
	    <span class="enscript-comment">/* Try NT response */</span>
	    sparams-&gt;utils-&gt;log(NULL, SASL_LOG_DEBUG,
				<span class="enscript-string">&quot;calculating NT response&quot;</span>);
	    P24(resp, P21(hash, password, P16_nt, sparams-&gt;utils,
			  &amp;text-&gt;out_buf, &amp;text-&gt;out_buf_len, &amp;result),
		text-&gt;nonce);
	    <span class="enscript-keyword">if</span> (memcmp(nt_resp, resp, NTLM_RESP_LENGTH)) {
		SETERROR(sparams-&gt;utils, <span class="enscript-string">&quot;incorrect NTLM response&quot;</span>);
		result = SASL_BADAUTH;
	    }
	}
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (lm_resp) {
	    <span class="enscript-comment">/* Try LMv2 response */</span>
	    sparams-&gt;utils-&gt;log(NULL, SASL_LOG_DEBUG,
				<span class="enscript-string">&quot;calculating LMv2 response&quot;</span>);
	    V2(resp, password, authid, domain, text-&gt;nonce,
	       lm_resp + MD5_DIGEST_LENGTH, lm_resp_len - MD5_DIGEST_LENGTH,
	       sparams-&gt;utils, &amp;text-&gt;out_buf, &amp;text-&gt;out_buf_len,
	       &amp;result);
		
	    <span class="enscript-comment">/* No need to compare the blob */</span>
	    <span class="enscript-keyword">if</span> (memcmp(lm_resp, resp, MD5_DIGEST_LENGTH)) {
		<span class="enscript-comment">/* Try LM response */</span>
		sparams-&gt;utils-&gt;log(NULL, SASL_LOG_DEBUG,
				    <span class="enscript-string">&quot;calculating LM response&quot;</span>);
		P24(resp, P21(hash, password, P16_lm, sparams-&gt;utils,
			      &amp;text-&gt;out_buf, &amp;text-&gt;out_buf_len, &amp;result),
		    text-&gt;nonce);
		<span class="enscript-keyword">if</span> (memcmp(lm_resp, resp, NTLM_RESP_LENGTH)) {
		    SETERROR(sparams-&gt;utils, <span class="enscript-string">&quot;incorrect LMv1/v2 response&quot;</span>);
		    result = SASL_BADAUTH;
		}
	    }
	}

	_plug_free_secret(sparams-&gt;utils, &amp;password);

	<span class="enscript-keyword">if</span> (result != SASL_OK) <span class="enscript-keyword">goto</span> <span class="enscript-reference">cleanup</span>;
    }
    <span class="enscript-keyword">else</span> {
	<span class="enscript-comment">/* proxy the response */</span>
	result = smb_session_setup(sparams-&gt;utils, text, authid, domain,
				   lm_resp, lm_resp_len, nt_resp, nt_resp_len);
	<span class="enscript-keyword">if</span> (result != SASL_OK) <span class="enscript-keyword">goto</span> <span class="enscript-reference">cleanup</span>;

	result = sparams-&gt;canon_user(sparams-&gt;utils-&gt;conn, authid, authid_len,
				     SASL_CU_AUTHID | SASL_CU_AUTHZID, oparams);
	<span class="enscript-keyword">if</span> (result != SASL_OK) <span class="enscript-keyword">goto</span> <span class="enscript-reference">cleanup</span>;
    }

    <span class="enscript-comment">/* set oparams */</span>
    oparams-&gt;doneflag = 1;
    oparams-&gt;mech_ssf = 0;
    oparams-&gt;maxoutbuf = 0;
    oparams-&gt;encode_context = NULL;
    oparams-&gt;encode = NULL;
    oparams-&gt;decode_context = NULL;
    oparams-&gt;decode = NULL;
    oparams-&gt;param_version = 0;

    result = SASL_OK;

  <span class="enscript-reference">cleanup</span>:
    <span class="enscript-keyword">if</span> (lm_resp) sparams-&gt;utils-&gt;free(lm_resp);
    <span class="enscript-keyword">if</span> (nt_resp) sparams-&gt;utils-&gt;free(nt_resp);
    <span class="enscript-keyword">if</span> (domain) sparams-&gt;utils-&gt;free(domain);
    <span class="enscript-keyword">if</span> (authid) sparams-&gt;utils-&gt;free(authid);

    <span class="enscript-keyword">return</span> result;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">ntlm_server_mech_step</span>(<span class="enscript-type">void</span> *conn_context,
				 sasl_server_params_t *sparams,
				 <span class="enscript-type">const</span> <span class="enscript-type">char</span> *clientin,
				 <span class="enscript-type">unsigned</span> clientinlen,
				 <span class="enscript-type">const</span> <span class="enscript-type">char</span> **serverout,
				 <span class="enscript-type">unsigned</span> *serveroutlen,
				 sasl_out_params_t *oparams)
{
    server_context_t *text = (server_context_t *) conn_context;
    
    *serverout = NULL;
    *serveroutlen = 0;
    
    sparams-&gt;utils-&gt;log(NULL, SASL_LOG_DEBUG,
		       <span class="enscript-string">&quot;NTLM server step %d\n&quot;</span>, text-&gt;state);

    <span class="enscript-keyword">switch</span> (text-&gt;state) {
	
    <span class="enscript-keyword">case</span> <span class="enscript-reference">1</span>:
	<span class="enscript-keyword">return</span> ntlm_server_mech_step1(text, sparams, clientin, clientinlen,
				      serverout, serveroutlen, oparams);
	
    <span class="enscript-keyword">case</span> <span class="enscript-reference">2</span>:
	<span class="enscript-keyword">return</span> ntlm_server_mech_step2(text, sparams, clientin, clientinlen,
				      serverout, serveroutlen, oparams);
	
    <span class="enscript-reference">default</span>:
	sparams-&gt;utils-&gt;log(NULL, SASL_LOG_ERR,
			   <span class="enscript-string">&quot;Invalid NTLM server step %d\n&quot;</span>, text-&gt;state);
	<span class="enscript-keyword">return</span> SASL_FAIL;
    }
    
    <span class="enscript-keyword">return</span> SASL_FAIL; <span class="enscript-comment">/* should never get here */</span>
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">ntlm_server_mech_dispose</span>(<span class="enscript-type">void</span> *conn_context,
				     <span class="enscript-type">const</span> sasl_utils_t *utils)
{
    server_context_t *text = (server_context_t *) conn_context;
    
    <span class="enscript-keyword">if</span> (!text) <span class="enscript-keyword">return</span>;
    
    <span class="enscript-keyword">if</span> (text-&gt;out_buf) utils-&gt;free(text-&gt;out_buf);
    <span class="enscript-keyword">if</span> (text-&gt;sock != -1) closesocket(text-&gt;sock);

    utils-&gt;free(text);
}

<span class="enscript-type">static</span> sasl_server_plug_t ntlm_server_plugins[] = 
{
    {
	<span class="enscript-string">&quot;NTLM&quot;</span>,				<span class="enscript-comment">/* mech_name */</span>
	0,				<span class="enscript-comment">/* max_ssf */</span>
	SASL_SEC_NOPLAINTEXT
	| SASL_SEC_NOANONYMOUS,		<span class="enscript-comment">/* security_flags */</span>
	SASL_FEAT_WANT_CLIENT_FIRST,	<span class="enscript-comment">/* features */</span>
	NULL,				<span class="enscript-comment">/* glob_context */</span>
	&amp;ntlm_server_mech_new,		<span class="enscript-comment">/* mech_new */</span>
	&amp;ntlm_server_mech_step,		<span class="enscript-comment">/* mech_step */</span>
	&amp;ntlm_server_mech_dispose,	<span class="enscript-comment">/* mech_dispose */</span>
	NULL,				<span class="enscript-comment">/* mech_free */</span>
	NULL,				<span class="enscript-comment">/* setpass */</span>
	NULL,				<span class="enscript-comment">/* user_query */</span>
	NULL,				<span class="enscript-comment">/* idle */</span>
	NULL,				<span class="enscript-comment">/* mech_avail */</span>
	NULL				<span class="enscript-comment">/* spare */</span>
    }
};

<span class="enscript-type">int</span> <span class="enscript-function-name">ntlm_server_plug_init</span>(sasl_utils_t *utils,
			  <span class="enscript-type">int</span> maxversion,
			  <span class="enscript-type">int</span> *out_version,
			  sasl_server_plug_t **pluglist,
			  <span class="enscript-type">int</span> *plugcount)
{
    <span class="enscript-keyword">if</span> (maxversion &lt; SASL_SERVER_PLUG_VERSION) {
	SETERROR(utils, <span class="enscript-string">&quot;NTLM version mismatch&quot;</span>);
	<span class="enscript-keyword">return</span> SASL_BADVERS;
    }
    
    *out_version = SASL_SERVER_PLUG_VERSION;
    *pluglist = ntlm_server_plugins;
    *plugcount = 1;
    
    <span class="enscript-keyword">return</span> SASL_OK;
}

<span class="enscript-comment">/*****************************  Client Section  *****************************/</span>

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> client_context {
    <span class="enscript-type">int</span> state;

    <span class="enscript-comment">/* per-step mem management */</span>
    <span class="enscript-type">char</span> *out_buf;
    <span class="enscript-type">unsigned</span> out_buf_len;

} client_context_t;

<span class="enscript-comment">/*
 * Create a client request (type 1) consisting of:
 *
 * signature (8 bytes)
 * message type (uint32)
 * flags (uint32)
 * domain (buffer)
 * workstation (buffer)
 * data
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">create_request</span>(<span class="enscript-type">const</span> sasl_utils_t *utils,
			  <span class="enscript-type">char</span> **buf, <span class="enscript-type">unsigned</span> *buflen,
			  <span class="enscript-type">const</span> <span class="enscript-type">char</span> *domain, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *wkstn,
			  <span class="enscript-type">unsigned</span> *outlen)
{
    uint32 flags = ( NTLM_USE_UNICODE | NTLM_USE_ASCII |
		     NTLM_ASK_TARGET | NTLM_AUTH_NTLM );
    uint32 offset = NTLM_TYPE1_DATA_OFFSET;
    u_char *base;

    *outlen = offset + xstrlen(domain) + xstrlen(wkstn);
    <span class="enscript-keyword">if</span> (_plug_buf_alloc(utils, buf, buflen, *outlen) != SASL_OK) {
	SETERROR(utils, <span class="enscript-string">&quot;cannot allocate NTLM request&quot;</span>);
	<span class="enscript-keyword">return</span> SASL_NOMEM;
    }

    base = (u_char *)*buf;
    memset(base, 0, *outlen);
    memcpy(base + NTLM_SIG_OFFSET, NTLM_SIGNATURE, <span class="enscript-keyword">sizeof</span>(NTLM_SIGNATURE));
    htoil(base + NTLM_TYPE_OFFSET, NTLM_TYPE_REQUEST);
    htoil(base + NTLM_TYPE1_FLAGS_OFFSET, flags);
    load_buffer(base + NTLM_TYPE1_DOMAIN_OFFSET,
		domain, (uint16) xstrlen(domain), 0, base, &amp;offset);
    load_buffer(base + NTLM_TYPE1_WORKSTN_OFFSET,
		wkstn, (uint16) xstrlen(wkstn), 0, base, &amp;offset);

    <span class="enscript-keyword">return</span> SASL_OK;
}

<span class="enscript-comment">/*
 * Create a client response (type 3) consisting of:
 *
 * signature (8 bytes)
 * message type (uint32)
 * LM/LMv2 response (buffer)
 * NTLM/NTLMv2 response (buffer)
 * domain (buffer)
 * user name (buffer)
 * workstation (buffer)
 * session key (buffer)
 * flags (uint32)
 * data
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">create_response</span>(<span class="enscript-type">const</span> sasl_utils_t *utils,
			   <span class="enscript-type">char</span> **buf, <span class="enscript-type">unsigned</span> *buflen,
			   <span class="enscript-type">const</span> u_char *lm_resp, <span class="enscript-type">const</span> u_char *nt_resp,
			   <span class="enscript-type">const</span> <span class="enscript-type">char</span> *domain, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *user,
			   <span class="enscript-type">const</span> <span class="enscript-type">char</span> *wkstn, <span class="enscript-type">const</span> u_char *key,
			   uint32 flags, <span class="enscript-type">unsigned</span> *outlen)
{
    uint32 offset = NTLM_TYPE3_DATA_OFFSET;
    u_char *base;

    <span class="enscript-keyword">if</span> (!lm_resp &amp;&amp; !nt_resp) {
	SETERROR(utils, <span class="enscript-string">&quot;need at least one NT/LM response&quot;</span>);
	<span class="enscript-keyword">return</span> SASL_FAIL;
    }

    *outlen = offset + (flags &amp; NTLM_USE_UNICODE ? 2 : 1) * 
	(xstrlen(domain) + xstrlen(user) + xstrlen(wkstn));
    <span class="enscript-keyword">if</span> (lm_resp) *outlen += NTLM_RESP_LENGTH;
    <span class="enscript-keyword">if</span> (nt_resp) *outlen += NTLM_RESP_LENGTH;
    <span class="enscript-keyword">if</span> (key) *outlen += NTLM_SESSKEY_LENGTH;

    <span class="enscript-keyword">if</span> (_plug_buf_alloc(utils, buf, buflen, *outlen) != SASL_OK) {
	SETERROR(utils, <span class="enscript-string">&quot;cannot allocate NTLM response&quot;</span>);
	<span class="enscript-keyword">return</span> SASL_NOMEM;
    }

    base = (u_char *)*buf;
    memset(base, 0, *outlen);
    memcpy(base + NTLM_SIG_OFFSET, NTLM_SIGNATURE, <span class="enscript-keyword">sizeof</span>(NTLM_SIGNATURE));
    htoil(base + NTLM_TYPE_OFFSET, NTLM_TYPE_RESPONSE);
    load_buffer(base + NTLM_TYPE3_LMRESP_OFFSET,
		lm_resp, lm_resp ? NTLM_RESP_LENGTH : 0, 0, base, &amp;offset);
    load_buffer(base + NTLM_TYPE3_NTRESP_OFFSET,
		nt_resp, nt_resp ? NTLM_RESP_LENGTH : 0, 0, base, &amp;offset);
    load_buffer(base + NTLM_TYPE3_DOMAIN_OFFSET,
		ucase(domain, 0), (uint16) xstrlen(domain), flags &amp; NTLM_USE_UNICODE,
		base, &amp;offset);
    load_buffer(base + NTLM_TYPE3_USER_OFFSET,
		user, (uint16) xstrlen(user), flags &amp; NTLM_USE_UNICODE, base, &amp;offset);
    load_buffer(base + NTLM_TYPE3_WORKSTN_OFFSET,
		ucase(wkstn, 0), (uint16) xstrlen(wkstn), flags &amp; NTLM_USE_UNICODE,
		base, &amp;offset);
    load_buffer(base + NTLM_TYPE3_SESSIONKEY_OFFSET,
		key, key ? NTLM_SESSKEY_LENGTH : 0, 0, base, &amp;offset);
    htoil(base + NTLM_TYPE3_FLAGS_OFFSET, flags);

    <span class="enscript-keyword">return</span> SASL_OK;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">ntlm_client_mech_new</span>(<span class="enscript-type">void</span> *glob_context __attribute__((unused)),
			       sasl_client_params_t *params,
			       <span class="enscript-type">void</span> **conn_context)
{
    client_context_t *text;
    
    <span class="enscript-comment">/* holds state are in */</span>
    text = params-&gt;utils-&gt;malloc(<span class="enscript-keyword">sizeof</span>(client_context_t));
    <span class="enscript-keyword">if</span> (text == NULL) {
	MEMERROR( params-&gt;utils );
	<span class="enscript-keyword">return</span> SASL_NOMEM;
    }
    
    memset(text, 0, <span class="enscript-keyword">sizeof</span>(client_context_t));
    
    text-&gt;state = 1;
    
    *conn_context = text;
    
    <span class="enscript-keyword">return</span> SASL_OK;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">ntlm_client_mech_step1</span>(client_context_t *text,
				  sasl_client_params_t *params,
				  <span class="enscript-type">const</span> <span class="enscript-type">char</span> *serverin __attribute__((unused)),
				  <span class="enscript-type">unsigned</span> serverinlen __attribute__((unused)),
				  sasl_interact_t **prompt_need __attribute__((unused)),
				  <span class="enscript-type">const</span> <span class="enscript-type">char</span> **clientout,
				  <span class="enscript-type">unsigned</span> *clientoutlen,
				  sasl_out_params_t *oparams __attribute__((unused)))
{
    <span class="enscript-type">int</span> result;
    
    <span class="enscript-comment">/* check if sec layer strong enough */</span>
    <span class="enscript-keyword">if</span> (params-&gt;props.min_ssf &gt; params-&gt;external_ssf) {
	SETERROR(params-&gt;utils, <span class="enscript-string">&quot;SSF requested of NTLM plugin&quot;</span>);
	<span class="enscript-keyword">return</span> SASL_TOOWEAK;
    }

    <span class="enscript-comment">/* we don't care about domain or wkstn */</span>
    result = create_request(params-&gt;utils, &amp;text-&gt;out_buf, &amp;text-&gt;out_buf_len,
			    NULL, NULL, clientoutlen);
    <span class="enscript-keyword">if</span> (result != SASL_OK) <span class="enscript-keyword">return</span> result;

    *clientout = text-&gt;out_buf;
    
    text-&gt;state = 2;
    
    <span class="enscript-keyword">return</span> SASL_CONTINUE;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">ntlm_client_mech_step2</span>(client_context_t *text,
				  sasl_client_params_t *params,
				  <span class="enscript-type">const</span> <span class="enscript-type">char</span> *serverin,
				  <span class="enscript-type">unsigned</span> serverinlen,
				  sasl_interact_t **prompt_need,
				  <span class="enscript-type">const</span> <span class="enscript-type">char</span> **clientout,
				  <span class="enscript-type">unsigned</span> *clientoutlen,
				  sasl_out_params_t *oparams)
{
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> *authid = NULL;
    sasl_secret_t *password = NULL;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> free_password; <span class="enscript-comment">/* set if we need to free password */</span>
    <span class="enscript-type">char</span> *domain = NULL;
    <span class="enscript-type">int</span> auth_result = SASL_OK;
    <span class="enscript-type">int</span> pass_result = SASL_OK;
    uint32 flags = 0;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> hash[NTLM_HASH_LENGTH];
    <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> resp[NTLM_RESP_LENGTH], *lm_resp = NULL, *nt_resp = NULL;
    <span class="enscript-type">int</span> result;
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> *sendv2;

    <span class="enscript-keyword">if</span> (!serverin || serverinlen &lt; NTLM_TYPE2_MINSIZE ||
	memcmp(serverin, NTLM_SIGNATURE, <span class="enscript-keyword">sizeof</span>(NTLM_SIGNATURE)) ||
	itohl(serverin + NTLM_TYPE_OFFSET) != NTLM_TYPE_CHALLENGE) {
	SETERROR(params-&gt;utils, <span class="enscript-string">&quot;server didn't issue valid NTLM challenge&quot;</span>);
	<span class="enscript-keyword">return</span> SASL_BADPROT;
    }

    <span class="enscript-comment">/* try to get the authid */</span>
    <span class="enscript-keyword">if</span> (oparams-&gt;authid == NULL) {
	auth_result = _plug_get_authid(params-&gt;utils, &amp;authid, prompt_need);
	
	<span class="enscript-keyword">if</span> ((auth_result != SASL_OK) &amp;&amp; (auth_result != SASL_INTERACT))
	    <span class="enscript-keyword">return</span> auth_result;
    }
    
    <span class="enscript-comment">/* try to get the password */</span>
    <span class="enscript-keyword">if</span> (password == NULL) {
	pass_result = _plug_get_password(params-&gt;utils, &amp;password,
					 &amp;free_password, prompt_need);
	
	<span class="enscript-keyword">if</span> ((pass_result != SASL_OK) &amp;&amp; (pass_result != SASL_INTERACT))
	    <span class="enscript-keyword">return</span> pass_result;
    }

    <span class="enscript-comment">/* free prompts we got */</span>
    <span class="enscript-keyword">if</span> (prompt_need &amp;&amp; *prompt_need) {
	params-&gt;utils-&gt;free(*prompt_need);
	*prompt_need = NULL;
    }
    
    <span class="enscript-comment">/* if there are prompts not filled in */</span>
    <span class="enscript-keyword">if</span> ((auth_result == SASL_INTERACT) || (pass_result == SASL_INTERACT)) {
	<span class="enscript-comment">/* make the prompt list */</span>
	result =
	    _plug_make_prompts(params-&gt;utils, prompt_need,
			       NULL, NULL,
			       auth_result == SASL_INTERACT ?
			       <span class="enscript-string">&quot;Please enter your authentication name&quot;</span> : NULL,
			       NULL,
			       pass_result == SASL_INTERACT ?
			       <span class="enscript-string">&quot;Please enter your password&quot;</span> : NULL, NULL,
			       NULL, NULL, NULL,
			       NULL, NULL, NULL);
	<span class="enscript-keyword">if</span> (result != SASL_OK) <span class="enscript-keyword">goto</span> <span class="enscript-reference">cleanup</span>;
	
	<span class="enscript-keyword">return</span> SASL_INTERACT;
    }
    
    result = params-&gt;canon_user(params-&gt;utils-&gt;conn, authid, 0,
				SASL_CU_AUTHID | SASL_CU_AUTHZID, oparams);
    <span class="enscript-keyword">if</span> (result != SASL_OK) <span class="enscript-keyword">goto</span> <span class="enscript-reference">cleanup</span>;

    flags = itohl(serverin + NTLM_TYPE2_FLAGS_OFFSET);
    params-&gt;utils-&gt;log(NULL, SASL_LOG_DEBUG,
		       <span class="enscript-string">&quot;server flags: %x&quot;</span>, flags);

    flags &amp;= NTLM_FLAGS_MASK; <span class="enscript-comment">/* mask off the bits we don't support */</span>

    result = unload_buffer(params-&gt;utils, (<span class="enscript-type">const</span> u_char *)serverin + NTLM_TYPE2_TARGET_OFFSET,
			   (u_char **) &amp;domain, NULL,
			   flags &amp; NTLM_USE_UNICODE,
			   (u_char *) serverin, serverinlen);
    <span class="enscript-keyword">if</span> (result != SASL_OK) <span class="enscript-keyword">goto</span> <span class="enscript-reference">cleanup</span>;
    params-&gt;utils-&gt;log(NULL, SASL_LOG_DEBUG,
		       <span class="enscript-string">&quot;server domain: %s&quot;</span>, domain);

    <span class="enscript-comment">/* should we send a NTLMv2 response? */</span>
    params-&gt;utils-&gt;getopt(params-&gt;utils-&gt;getopt_context,
			  <span class="enscript-string">&quot;NTLM&quot;</span>, <span class="enscript-string">&quot;ntlm_v2&quot;</span>, &amp;sendv2, NULL);
    <span class="enscript-keyword">if</span> (sendv2 &amp;&amp;
	(*sendv2 == <span class="enscript-string">'1'</span> || *sendv2 == <span class="enscript-string">'y'</span> ||
	 (*sendv2 == <span class="enscript-string">'o'</span> &amp;&amp; *sendv2 == <span class="enscript-string">'n'</span>) || *sendv2 == <span class="enscript-string">'t'</span>)) {

	<span class="enscript-comment">/* put the cnonce in place after the LMv2 HMAC */</span>
	<span class="enscript-type">char</span> *cnonce = (<span class="enscript-type">char</span> *)(resp + MD5_DIGEST_LENGTH);
	
	params-&gt;utils-&gt;log(NULL, SASL_LOG_DEBUG,
			   <span class="enscript-string">&quot;calculating LMv2 response&quot;</span>);

	params-&gt;utils-&gt;rand(params-&gt;utils-&gt;rpool, cnonce, NTLM_NONCE_LENGTH);

	V2(resp, password, oparams-&gt;authid, domain,
	   serverin + NTLM_TYPE2_CHALLENGE_OFFSET, cnonce, NTLM_NONCE_LENGTH,
	   params-&gt;utils, &amp;text-&gt;out_buf, &amp;text-&gt;out_buf_len, &amp;result);

	lm_resp = resp;
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (flags &amp; NTLM_AUTH_NTLM) {
	params-&gt;utils-&gt;log(NULL, SASL_LOG_DEBUG,
			   <span class="enscript-string">&quot;calculating NT response&quot;</span>);
	P24(resp, P21(hash, password, P16_nt, params-&gt;utils,
		      &amp;text-&gt;out_buf, &amp;text-&gt;out_buf_len, &amp;result),
	    (<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *) serverin + NTLM_TYPE2_CHALLENGE_OFFSET);
	nt_resp = resp;
    }
    <span class="enscript-keyword">else</span> {
	params-&gt;utils-&gt;log(NULL, SASL_LOG_DEBUG,
			   <span class="enscript-string">&quot;calculating LM response&quot;</span>);
	P24(resp, P21(hash, password, P16_lm, params-&gt;utils,
		      &amp;text-&gt;out_buf, &amp;text-&gt;out_buf_len, &amp;result),
	    (<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *) serverin + NTLM_TYPE2_CHALLENGE_OFFSET);
	lm_resp = resp;
    }
    <span class="enscript-keyword">if</span> (result != SASL_OK) <span class="enscript-keyword">goto</span> <span class="enscript-reference">cleanup</span>;

    <span class="enscript-comment">/* we don't care about workstn or session key */</span>
    result = create_response(params-&gt;utils, &amp;text-&gt;out_buf, &amp;text-&gt;out_buf_len,
			     lm_resp, nt_resp, domain, oparams-&gt;authid,
			     NULL, NULL, flags, clientoutlen);
    <span class="enscript-keyword">if</span> (result != SASL_OK) <span class="enscript-keyword">goto</span> <span class="enscript-reference">cleanup</span>;

    *clientout = text-&gt;out_buf;

    <span class="enscript-comment">/* set oparams */</span>
    oparams-&gt;doneflag = 1;
    oparams-&gt;mech_ssf = 0;
    oparams-&gt;maxoutbuf = 0;
    oparams-&gt;encode_context = NULL;
    oparams-&gt;encode = NULL;
    oparams-&gt;decode_context = NULL;
    oparams-&gt;decode = NULL;
    oparams-&gt;param_version = 0;
    
    result = SASL_OK;

  <span class="enscript-reference">cleanup</span>:
    <span class="enscript-keyword">if</span> (domain) params-&gt;utils-&gt;free(domain);
    <span class="enscript-keyword">if</span> (free_password) _plug_free_secret(params-&gt;utils, &amp;password);

    <span class="enscript-keyword">return</span> result;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">ntlm_client_mech_step</span>(<span class="enscript-type">void</span> *conn_context,
				sasl_client_params_t *params,
				<span class="enscript-type">const</span> <span class="enscript-type">char</span> *serverin,
				<span class="enscript-type">unsigned</span> serverinlen,
				sasl_interact_t **prompt_need,
				<span class="enscript-type">const</span> <span class="enscript-type">char</span> **clientout,
				<span class="enscript-type">unsigned</span> *clientoutlen,
				sasl_out_params_t *oparams)
{
    client_context_t *text = (client_context_t *) conn_context;
    
    *clientout = NULL;
    *clientoutlen = 0;
    
    params-&gt;utils-&gt;log(NULL, SASL_LOG_DEBUG,
		       <span class="enscript-string">&quot;NTLM client step %d\n&quot;</span>, text-&gt;state);

    <span class="enscript-keyword">switch</span> (text-&gt;state) {
	
    <span class="enscript-keyword">case</span> <span class="enscript-reference">1</span>:
	<span class="enscript-keyword">return</span> ntlm_client_mech_step1(text, params, serverin, serverinlen,
				      prompt_need, clientout, clientoutlen,
				      oparams);
	
    <span class="enscript-keyword">case</span> <span class="enscript-reference">2</span>:
	<span class="enscript-keyword">return</span> ntlm_client_mech_step2(text, params, serverin, serverinlen,
				      prompt_need, clientout, clientoutlen,
				      oparams);
	
    <span class="enscript-reference">default</span>:
	params-&gt;utils-&gt;log(NULL, SASL_LOG_ERR,
			   <span class="enscript-string">&quot;Invalid NTLM client step %d\n&quot;</span>, text-&gt;state);
	<span class="enscript-keyword">return</span> SASL_FAIL;
    }
    
    <span class="enscript-keyword">return</span> SASL_FAIL; <span class="enscript-comment">/* should never get here */</span>
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">ntlm_client_mech_dispose</span>(<span class="enscript-type">void</span> *conn_context,
				    <span class="enscript-type">const</span> sasl_utils_t *utils)
{
    client_context_t *text = (client_context_t *) conn_context;
    
    <span class="enscript-keyword">if</span> (!text) <span class="enscript-keyword">return</span>;
    
    <span class="enscript-keyword">if</span> (text-&gt;out_buf) utils-&gt;free(text-&gt;out_buf);
    
    utils-&gt;free(text);
}

<span class="enscript-type">static</span> sasl_client_plug_t ntlm_client_plugins[] = 
{
    {
	<span class="enscript-string">&quot;NTLM&quot;</span>,				<span class="enscript-comment">/* mech_name */</span>
	0,				<span class="enscript-comment">/* max_ssf */</span>
	SASL_SEC_NOPLAINTEXT
	| SASL_SEC_NOANONYMOUS,		<span class="enscript-comment">/* security_flags */</span>
	SASL_FEAT_WANT_CLIENT_FIRST,	<span class="enscript-comment">/* features */</span>
	NULL,				<span class="enscript-comment">/* required_prompts */</span>
	NULL,				<span class="enscript-comment">/* glob_context */</span>
	&amp;ntlm_client_mech_new,		<span class="enscript-comment">/* mech_new */</span>
	&amp;ntlm_client_mech_step,		<span class="enscript-comment">/* mech_step */</span>
	&amp;ntlm_client_mech_dispose,	<span class="enscript-comment">/* mech_dispose */</span>
	NULL,				<span class="enscript-comment">/* mech_free */</span>
	NULL,				<span class="enscript-comment">/* idle */</span>
	NULL,				<span class="enscript-comment">/* spare */</span>
	NULL				<span class="enscript-comment">/* spare */</span>
    }
};

<span class="enscript-type">int</span> <span class="enscript-function-name">ntlm_client_plug_init</span>(sasl_utils_t *utils,
			 <span class="enscript-type">int</span> maxversion,
			 <span class="enscript-type">int</span> *out_version,
			 sasl_client_plug_t **pluglist,
			 <span class="enscript-type">int</span> *plugcount)
{
    <span class="enscript-keyword">if</span> (maxversion &lt; SASL_CLIENT_PLUG_VERSION) {
	SETERROR(utils, <span class="enscript-string">&quot;NTLM version mismatch&quot;</span>);
	<span class="enscript-keyword">return</span> SASL_BADVERS;
    }
    
    *out_version = SASL_CLIENT_PLUG_VERSION;
    *pluglist = ntlm_client_plugins;
    *plugcount = 1;
    
    <span class="enscript-keyword">return</span> SASL_OK;
}
</pre>
<hr />
</body></html>